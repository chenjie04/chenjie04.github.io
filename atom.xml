<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chenjie04.github.io</id>
    <title>chenjie04&apos;s blog</title>
    <updated>2023-07-24T14:20:13.792Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chenjie04.github.io"/>
    <link rel="self" href="https://chenjie04.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://chenjie04.github.io/images/avatar.png</logo>
    <icon>https://chenjie04.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, chenjie04&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[双线性插值法的直观理解]]></title>
        <id>https://chenjie04.github.io/post/shuang-xian-xing-cha-zhi-fa-de-zhi-guan-li-jie/</id>
        <link href="https://chenjie04.github.io/post/shuang-xian-xing-cha-zhi-fa-de-zhi-guan-li-jie/">
        </link>
        <updated>2023-07-24T13:23:44.000Z</updated>
        <content type="html"><![CDATA[<p>在学习可变形卷积的过程中，涉及到给采样点加上偏移量进行卷积感受野变形的操作，但是偏移量是浮点数，偏移后一般不能保证刚好落到某个像素点上，多是落到类似（10.3，25.7）这样的虚拟像素点上，这样我们就需要用到双线性插值法来计算出虚拟像素点的值。</p>
<p>双线性插值法就是找出虚拟像素点周围最近的4个真实像素点，然后对这4个像素点的值进行加权求和，作为虚拟像素的值。</p>
<figure data-type="image" tabindex="1"><img src="https://chenjie04.github.io/post-images/1690206492744.jpg" alt="图片来自: https://zhuanlan.zhihu.com/p/110754637" loading="lazy"></figure>
<p>如上图所示（图片来自: <a href="https://zhuanlan.zhihu.com/p/110754637">https://zhuanlan.zhihu.com/p/110754637</a>），假设我们的虚拟像素点为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">P(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>。首先，我们需要找出周围最近的4个真实像素点: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><mn>11</mn><mo>(</mo><mi>x</mi><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">Q11(x1,y1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mord">1</span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><mn>12</mn><mo>(</mo><mi>x</mi><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">Q12(x1,y2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mord">1</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><mn>21</mn><mo>(</mo><mi>x</mi><mn>2</mn><mo separator="true">,</mo><mi>y</mi><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">Q21(x2,y1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mord">2</span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><mn>22</mn><mo>(</mo><mi>x</mi><mn>2</mn><mo separator="true">,</mo><mi>y</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">Q22(x2,y2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mord">2</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>。怎么找？简单！<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>向下取整得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">x1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>1</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x1+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">x2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span></span></span></span>；<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>向下取整得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">y1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mn>1</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">y1+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">y2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span></span></span></span>；支持4个点全部找到。</p>
<p>然后，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><mn>11</mn><mo>(</mo><mi>x</mi><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">Q11(x1,y1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mord">1</span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><mn>21</mn><mo>(</mo><mi>x</mi><mn>2</mn><mo separator="true">,</mo><mi>y</mi><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">Q21(x2,y1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mord">2</span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>进行一个x方向的插值，求出点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">R1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">1</span></span></span></span>的值（记为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>R</mi><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f(R1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，其他点同理）。具体怎么做？我们说<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">R1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">1</span></span></span></span>越靠近<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><mn>11</mn></mrow><annotation encoding="application/x-tex">Q11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mord">1</span><span class="mord">1</span></span></span></span>，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>Q</mi><mn>11</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f(Q11)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mord">1</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>的权重就应该越大，反之越小。很直观，很合理吧？从图中，我们可以看到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">R1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">1</span></span></span></span>刚好把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mn>2</mn><mo>−</mo><mi>x</mi><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(x2 - x1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>分成了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>2</mn><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x2-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mi>x</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">x-x1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span></span></span></span>两段。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">R1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">1</span></span></span></span>越靠近<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><mn>11</mn></mrow><annotation encoding="application/x-tex">Q11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mord">1</span><span class="mord">1</span></span></span></span>，段<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>2</mn><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x2-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>越长，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mi>x</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">x-x1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span></span></span></span>越短，那么我们把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>2</mn><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x2-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>/<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>2</mn><mo>−</mo><mi>x</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">x2 - x1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span></span></span></span>作为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>Q</mi><mn>11</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f(Q11)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mord">1</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>的权重不就好了吗？同样<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mi>x</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">x-x1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span></span></span></span>/<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>2</mn><mo>−</mo><mi>x</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">x2 - x1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span></span></span></span>作为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>Q</mi><mn>21</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f(Q21)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mord">2</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>的权重，则有：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>R</mi><mn>1</mn><mo>)</mo><mo>=</mo><mfrac><mrow><mi>x</mi><mn>2</mn><mo>−</mo><mi>x</mi></mrow><mrow><mi>x</mi><mn>2</mn><mo>−</mo><mi>x</mi><mn>1</mn></mrow></mfrac><mi>f</mi><mo>(</mo><mi>Q</mi><mn>11</mn><mo>)</mo><mo>+</mo><mfrac><mrow><mi>x</mi><mo>−</mo><mi>x</mi><mn>1</mn></mrow><mrow><mi>x</mi><mn>2</mn><mo>−</mo><mi>x</mi><mn>1</mn></mrow></mfrac><mi>f</mi><mo>(</mo><mi>Q</mi><mn>21</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f(R1) = \frac{x2-x}{x2-x1} f(Q11) + \frac{x-x1}{x2-x1} f(Q21)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mord">1</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mord">2</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p>同样，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><mn>12</mn><mo>(</mo><mi>x</mi><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">Q12(x1,y2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mord">1</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><mn>22</mn><mo>(</mo><mi>x</mi><mn>2</mn><mo separator="true">,</mo><mi>y</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">Q22(x2,y2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mord">2</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>进行一个x方向的插值，求出点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">R2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">2</span></span></span></span>的值:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>R</mi><mn>2</mn><mo>)</mo><mo>=</mo><mfrac><mrow><mi>x</mi><mn>2</mn><mo>−</mo><mi>x</mi></mrow><mrow><mi>x</mi><mn>2</mn><mo>−</mo><mi>x</mi><mn>1</mn></mrow></mfrac><mi>f</mi><mo>(</mo><mi>Q</mi><mn>12</mn><mo>)</mo><mo>+</mo><mfrac><mrow><mi>x</mi><mo>−</mo><mi>x</mi><mn>1</mn></mrow><mrow><mi>x</mi><mn>2</mn><mo>−</mo><mi>x</mi><mn>1</mn></mrow></mfrac><mi>f</mi><mo>(</mo><mi>Q</mi><mn>21</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f(R2) = \frac{x2-x}{x2-x1} f(Q12) + \frac{x-x1}{x2-x1} f(Q21)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mord">1</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mord">2</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p>最后，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mn>1</mn><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">R1(x,y1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mn>2</mn><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">R2(x,y2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>进行一个y方向的插值，就求出点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">P(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>的值:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>P</mi><mo>)</mo><mo>=</mo><mfrac><mrow><mi>y</mi><mn>2</mn><mo>−</mo><mi>y</mi></mrow><mrow><mi>y</mi><mn>2</mn><mo>−</mo><mi>y</mi><mn>1</mn></mrow></mfrac><mi>f</mi><mo>(</mo><mi>R</mi><mn>1</mn><mo>)</mo><mo>+</mo><mfrac><mrow><mi>y</mi><mo>−</mo><mi>y</mi><mn>1</mn></mrow><mrow><mi>y</mi><mn>2</mn><mo>−</mo><mi>y</mi><mn>1</mn></mrow></mfrac><mi>f</mi><mo>(</mo><mi>R</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f(P) = \frac{y2-y}{y2-y1} f(R1) + \frac{y-y1}{y2-y1} f(R2)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.20188em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.20188em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span></p>
<p>把前面求得的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>R</mi><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f(R1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>R</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f(R2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>代进来得：<br>
<img src="https://chenjie04.github.io/post-images/1690208322667.png" alt="" loading="lazy"></p>
<p>因为分母都为1，所以得<br>
<img src="https://chenjie04.github.io/post-images/1690208385401.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[卷积输出大小的计算详解]]></title>
        <id>https://chenjie04.github.io/post/juan-ji-shu-chu-da-xiao-de-ji-suan-xiang-jie/</id>
        <link href="https://chenjie04.github.io/post/juan-ji-shu-chu-da-xiao-de-ji-suan-xiang-jie/">
        </link>
        <updated>2023-07-19T02:00:25.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://chenjie04.github.io/post-images/1689732077671.png" alt="" loading="lazy"></figure>
<p>一直以来都没有详细计算过卷积输出大小的过程，都是需要的时候上网查，网上的教程都比较乱或者直接给出公式，不够形象，因此自己记录一下。</p>
<p>考虑上图的通用卷积场景：输入大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn><mo>×</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">9 \times 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span>，卷积核大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3 \times 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>，空洞因子（dilation rate）为3，卷积滑动步长为1，padding也为1。</p>
<p>首先，计算实际感受野的大小。考虑空洞卷积的情况下，实际上我们得在卷积核内隔一个像素插入一个空洞，即插入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>e</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">kernel\_size-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个空洞，每个空洞大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dilation-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，因此实际感受野为，</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>d</mi><mo>=</mo><mi>k</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>e</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>+</mo><mo>(</mo><mi>k</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>e</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>(</mo><mi>d</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">Filed=kernel\_size + (kernel\_size-1)(dilation-1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p>有人会进一步化简为，</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>d</mi><mo>=</mo><mi>d</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>×</mo><mo>(</mo><mi>k</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>e</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">Filed=dilation \times (kernel\_size-1)+1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>我还是习惯用最原始、最直观的计算公式来理解，</p>
<p>然后，我们回到上图，卷积是滑窗操作，不考虑第一个卷积计算，实际可滑动的距离d为多少？显然，就是图像大小加上padding后减去感受野的大小，即</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>=</mo><mi>w</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi><mo>+</mo><mn>2</mn><mo>×</mo><mi>p</mi><mi>a</mi><mi>d</mi><mo>−</mo><mo>(</mo><mi>k</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>e</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>+</mo><mo>(</mo><mi>k</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>e</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>(</mo><mi>d</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">d=width+2\times pad-(kernel\_size + (kernel\_size-1)(dilation-1))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
<p>那么，输出的特征图大小不就是滑动距离除以步长再加上第一个卷积计算嘛，那么输出大小为，</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>w</mi><mo>=</mo><mo>(</mo><mi>w</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi><mo>+</mo><mn>2</mn><mo>×</mo><mi>p</mi><mi>a</mi><mi>d</mi><mo>−</mo><mo>(</mo><mi>k</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>e</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>+</mo><mo>(</mo><mi>k</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>e</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>(</mo><mi>d</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>)</mo><mo>)</mo><mi mathvariant="normal">/</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>d</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>w</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">output\_w = (width+2\times pad-(kernel\_size + (kernel\_size-1)(dilation-1))) / stride\_w + 1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9250799999999999em;vertical-align:-0.31em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>一般来说，在卷积中，输入和卷积核都是正方形的，所以输出的高度计算公式也一样。另外，在代码实现的时候最好采用简化都是感受野计算公式，帮助减少点计算量，训练也会更快点嘛！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ROS2开发笔记——Launch系统（六）]]></title>
        <id>https://chenjie04.github.io/post/ros2-kai-fa-bi-ji-launch-xi-tong-liu/</id>
        <link href="https://chenjie04.github.io/post/ros2-kai-fa-bi-ji-launch-xi-tong-liu/">
        </link>
        <updated>2023-05-21T13:43:46.000Z</updated>
        <content type="html"><![CDATA[<p>在前面启动某个节点时，往往都是使用ros2 run命令，这样美启动一个节点都需要打开一个新的终端，显然不科学。那么，我们是如何管理我们的节点呢？答案就是用Launch系统。使用Launch系统可以同时启动多个节点，还可以配置节点的参数（parameter），注册事件处理函数等。</p>
<h1 id="一-launch系统的使用">一、Launch系统的使用</h1>
<p>Launch系统使用launch文件描述如何启动系统。在包目录下新建一个launch目录并新建turtlesim_mimic_launch.py文件，</p>
<pre><code class="language-python">from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration, TextSubstitution
from launch_ros.actions import Node

def generate_launch_description():
    background_r_launch_arg = DeclareLaunchArgument(
      'background_r', default_value=TextSubstitution(text='0')
   )
    background_g_launch_arg = DeclareLaunchArgument(
      'background_g', default_value=TextSubstitution(text='84')
   )
    background_b_launch_arg = DeclareLaunchArgument(
      'background_b', default_value=TextSubstitution(text='122')
   )
    return LaunchDescription([
        background_r_launch_arg,
        background_g_launch_arg,
        background_b_launch_arg,
        Node(
            package='turtlesim',
            namespace='turtlesim1',
            executable='turtlesim_node',
            name='sim'
        ),
        Node(
            package='turtlesim',
            namespace='turtlesim2',
            executable='turtlesim_node',
            name='sim',
            parameters=[{
                'background_r': LaunchConfiguration('background_r'),
                'background_g': LaunchConfiguration('background_g'),
                'background_b': LaunchConfiguration('background_b'),
         }]
        ),
        Node(
            package='turtlesim',
            executable='mimic',
            name='mimic',
            remappings=[
                ('/input/pose', '/turtlesim1/turtle1/pose'),
                ('/output/cmd_vel', '/turtlesim2/turtle1/cmd_vel'),
            ]
        )
    ])
</code></pre>
<p>首先导入相应的python模块，</p>
<pre><code class="language-python">from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration, TextSubstitution
from launch_ros.actions import Node
</code></pre>
<p>然后，开始描述加载，</p>
<pre><code class="language-python">def generate_launch_description():
   return LaunchDescription([

   ])
</code></pre>
<p>加载第一个节点，从turtlesim包执行turtlesim_node程序，并指定命名空间和节点名称。命名空间的存在，使得我们可以在不同命名空间下运行同名的节点。</p>
<pre><code class="language-python">Node(
    package='turtlesim',
    namespace='turtlesim1',
    executable='turtlesim_node',
    name='sim'
),
</code></pre>
<p>加载第二个节点，不过我们重新指定了窗口的背景颜色，并作为参数传递给节点，</p>
<pre><code class="language-python">  background_r_launch_arg = DeclareLaunchArgument(
      'background_r', default_value=TextSubstitution(text='0')
   )
   background_g_launch_arg = DeclareLaunchArgument(
      'background_g', default_value=TextSubstitution(text='84')
   )
   background_b_launch_arg = DeclareLaunchArgument(
      'background_b', default_value=TextSubstitution(text='122')
   )
   ...
   Node(
            package='turtlesim',
            namespace='turtlesim2',
            executable='turtlesim_node',
            name='sim',
            parameters=[{
                'background_r': LaunchConfiguration('background_r'),
                'background_g': LaunchConfiguration('background_g'),
                'background_b': LaunchConfiguration('background_b'),
         }]
        ),
</code></pre>
<p>第三个节点是想让第二个节点启动的小海龟模仿第一个节点启动的小海龟的行为，</p>
<pre><code class="language-python">Node(
            package='turtlesim',
            executable='mimic',
            name='mimic',
            remappings=[
                ('/input/pose', '/turtlesim1/turtle1/pose'),
                ('/output/cmd_vel', '/turtlesim2/turtle1/cmd_vel'),
            ]
        )
</code></pre>
<p>通过launch文件启动系统，</p>
<pre><code class="language-bash">$ ros2 launch &lt;package_name&gt; &lt;launch_file_name&gt;
</code></pre>
<p>编译之前需要在package.xml中加入以下依赖</p>
<pre><code class="language-xml">&lt;exec_depend&gt;ros2launch&lt;/exec_depend&gt;
</code></pre>
<p>执行之后，应该就会出现两个窗口，<br>
<img src="https://chenjie04.github.io/post-images/1684678794169.png" alt="" loading="lazy"></p>
<p>通过以下命令操纵第一个小海龟，第二个也跟着动，</p>
<pre><code class="language-bash">ros2 topic pub -r 1 /turtlesim1/turtle1/cmd_vel geometry_msgs/msg/Twist &quot;{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: -1.8}}&quot;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://chenjie04.github.io/post-images/1684678923552.png" alt="" loading="lazy"></figure>
<p>查看节点，</p>
<pre><code class="language-bash">$ rqt_graph
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://docs.ros.org/en/humble/_images/mimic_graph.png" alt="" loading="lazy"></figure>
<p>Launch系统还有很多高阶用法，请参考官方教程！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ROS2开发笔记——动作（action）样例（五）]]></title>
        <id>https://chenjie04.github.io/post/ros2-kai-fa-bi-ji-dong-zuo-actionyang-li/</id>
        <link href="https://chenjie04.github.io/post/ros2-kai-fa-bi-ji-dong-zuo-actionyang-li/">
        </link>
        <updated>2023-05-21T03:12:45.000Z</updated>
        <content type="html"><![CDATA[<p>Action是基于topic和service之上的通信方式，使用于那些需要较长时间执行的任务。Action通信示例如下，<br>
<img src="https://docs.ros.org/en/humble/_images/Action-SingleActionClient.gif" alt="" loading="lazy"></p>
<p>下面，我们将通过一个计算斐波那契 (Fibonacci)数列的例子演示action通信。在斐波那契数列中第一和第二个元素分别为0和1，然后其余每位元素是其前两位元素之和，因此需要一步步递归计算，属于需要较长时间执行的任务。</p>
<p>在数学上，斐波那契数定义如下，</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∗</mo><msub><mi>F</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn><mspace linebreak="newline"></mspace><mo>∗</mo><msub><mi>F</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn><mspace linebreak="newline"></mspace><mo>∗</mo><msub><mi>F</mi><mi>n</mi></msub><mo>=</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub><mo>(</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>)</mo><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">* F_{0} = 0 \\
* F_{1} = 1 \\
* F_{n} = F_{n-1} + F_{n-2} (n \leq 2) \\
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord">∗</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span><span class="mspace newline"></span></span></span></span></p>
<h1 id="一-action通信数据结构">一、Action通信数据结构</h1>
<p>新建包</p>
<pre><code class="language-bash">$ mkdir -p ros2_ws/src #you can reuse existing workspace with this naming convention
$ cd ros2_ws/src
$ ros2 pkg create action_tutorials_interfaces
</code></pre>
<pre><code class="language-bash">$ cd action_tutorials_interfaces
$ mkdir action
</code></pre>
<p>在action目录下新建接口文件Fibonacci.action。</p>
<p>Action通信构建于topic和service之上，客户端发起请求，服务端响应并返回结果，期间需要不断反馈任务进行进度，因此action通信的数据结构应当由以下三部分构成，</p>
<pre><code class="language-bash"># Request
---
# Result
---
# Feedback
</code></pre>
<p>首先，客户端发起的请求是求几阶的斐波那契数列，因此请求应该是整型数；服务端应该将对应的数列返回，因此结果应该是整型数组；而反馈是计算的中间结果，因此同样是整型数组。根据上述分析，定义数据结构如下，</p>
<pre><code class="language-C++">int32 order
---
int32[] sequence
---
int32[] partial_sequence
</code></pre>
<p>更新CMakeList.txt</p>
<pre><code class="language-C++">find_package(rosidl_default_generators REQUIRED)

rosidl_generate_interfaces(${PROJECT_NAME}
  &quot;action/Fibonacci.action&quot;
)
</code></pre>
<p>更新package.xml</p>
<pre><code class="language-xml">&lt;buildtool_depend&gt;rosidl_default_generators&lt;/buildtool_depend&gt;

&lt;depend&gt;action_msgs&lt;/depend&gt;

&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt;
</code></pre>
<p>编译</p>
<pre><code class="language-bash"># Change to the root of the workspace
$ cd ~/ros2_ws
# Build
$ colcon build
</code></pre>
<p>测试</p>
<pre><code class="language-bash"># Source our workspace
# On Windows: call install/setup.bat
$ . install/setup.bash
# Check that our action definition exists
$ ros2 interface show action_tutorials_interfaces/action/Fibonacci
</code></pre>
<h1 id="二-action通信样例">二、Action通信样例</h1>
<h2 id="1-环境准备">1、环境准备</h2>
<pre><code class="language-bash">$ ros2 pkg create --build-type ament_python action_tutorials_py
</code></pre>
<h2 id="2-编写actionserver">2、编写ActionServer</h2>
<p>在src/action_tutorials_py/action_tutorials_py下新建fibonacci_action_server.py文件，</p>
<pre><code class="language-python">import time

import rclpy
from rclpy.action import ActionServer # 导入ActionServer
from rclpy.node import Node

from action_tutorials_interfaces.action import Fibonacci


class FibonacciActionServer(Node):

    def __init__(self):
        super().__init__('fibonacci_action_server')
        # 初始化ActionServe
        self._action_server = ActionServer(
            self,
            Fibonacci,
            'fibonacci',
            self.execute_callback)

    def execute_callback(self, goal_handle):
        self.get_logger().info('Executing goal...') # 日志

        feedback_msg = Fibonacci.Feedback() # 实例化反馈信息，注意调用方式
        feedback_msg.partial_sequence = [0, 1] # 初始化反馈信息

        for i in range(1, goal_handle.request.order): # 从goal_handle获取请求
            # 迭代计算斐波那契数列，并将计算结果作为反馈信息发布
            feedback_msg.partial_sequence.append(
                feedback_msg.partial_sequence[i] + feedback_msg.partial_sequence[i-1])
            self.get_logger().info('Feedback: {0}'.format(feedback_msg.partial_sequence))
            goal_handle.publish_feedback(feedback_msg)
            time.sleep(1)

        goal_handle.succeed() # 任务执行完成后，将标志置为SUCCEED

        result = Fibonacci.Result() # 实例化结果信息
        result.sequence = feedback_msg.partial_sequence # 将最后一个反馈信息作为结果
        return result


def main(args=None):
    rclpy.init(args=args)

    fibonacci_action_server = FibonacciActionServer()

    rclpy.spin(fibonacci_action_server)


if __name__ == '__main__':
    main()
</code></pre>
<h2 id="3-编写actionclient">3、编写ActionClient</h2>
<p>在src/action_tutorials_py/action_tutorials_py下新建fibonacci_action_client.py文件，</p>
<pre><code class="language-python">import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node

from action_tutorials_interfaces.action import Fibonacci


class FibonacciActionClient(Node):

    def __init__(self):
        super().__init__('fibonacci_action_client')
        self._action_client = ActionClient(self, Fibonacci, 'fibonacci') #新建ActionClient，用过action的名字'fibonacci'与ActionServer建立通信

    def send_goal(self, order): # 发起请求的函数
        goal_msg = Fibonacci.Goal()
        goal_msg.order = order

        self._action_client.wait_for_server() # 等待服务

        self._send_goal_future = self._action_client.send_goal_async(goal_msg, feedback_callback=self.feedback_callback) # 异步执行，将请求发给server，返回一个future

        self._send_goal_future.add_done_callback(self.goal_response_callback) # 注册响应回调函数

    def goal_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().info('Goal rejected :(')
            return

        self.get_logger().info('Goal accepted :)')

        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def get_result_callback(self, future):
        result = future.result().result
        self.get_logger().info('Result: {0}'.format(result.sequence))
        rclpy.shutdown()

    def feedback_callback(self, feedback_msg):
        feedback = feedback_msg.feedback
        self.get_logger().info('Received feedback: {0}'.format(feedback.partial_sequence))


def main(args=None):
    rclpy.init(args=args)

    action_client = FibonacciActionClient()

    action_client.send_goal(10)

    rclpy.spin(action_client)


if __name__ == '__main__':
    main()
</code></pre>
<h2 id="4-更新依赖与程序执行入口">4、更新依赖与程序执行入口</h2>
<p>package.xml</p>
<pre><code class="language-xml">  &lt;depend&gt;action_tutorials_interfaces&lt;/depend&gt;

  &lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;
</code></pre>
<p>setup.py</p>
<pre><code class="language-python">entry_points={
        'console_scripts': [
            'fibonacci_action_server = action_tutorials_py.fibonacci_action_server:main',
            'fibonacci_action_client = action_tutorials_py.fibonacci_action_client:main',
        ],
    },
</code></pre>
<h2 id="5-编译与运行">5、编译与运行</h2>
<pre><code class="language-bash">$ colcon build --packages-select action_tutorials_py
</code></pre>
<pre><code class="language-bash">$ source install/setup.bash
$ ros2 run action_tutorials_py fibonacci_action_server
</code></pre>
<pre><code class="language-bash">$ source install/setup.bash
$ ros2 run action_tutorials_py fibonacci_action_client
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ROS2开发笔记——自定义数据结构（msg、srv）（四）]]></title>
        <id>https://chenjie04.github.io/post/ros2-kai-fa-bi-ji-zi-ding-yi-shu-ju-jie-gou-msgsrv/</id>
        <link href="https://chenjie04.github.io/post/ros2-kai-fa-bi-ji-zi-ding-yi-shu-ju-jie-gou-msgsrv/">
        </link>
        <updated>2023-05-17T02:05:25.000Z</updated>
        <content type="html"><![CDATA[<p>目前，我们学习的topic和service两种通信方式用的都是ROS预定义的数据结构，但是有时候为了满足特殊需求就得自定义数据结构。</p>
<p>一般而言，好的开发习惯是将数据结构放到独立的包中方便管理，也有数据结构的功能代码放到同一个包中的，例如官方教程中的<a href="https://docs.ros.org/en/humble/Tutorials/Beginner-Client-Libraries/Single-Package-Define-And-Use-Interface.html">Implementing custom interfaces</a>，这里，我们遵循官方建议的习惯，将数据结构放到独立的包中。</p>
<h1 id="一-新建包">一、新建包</h1>
<p>好像现在只支持用C++定义数据结构，在ros2_ws/src下新建数据结构包，</p>
<pre><code class="language-bash">$ ros2 pkg create --build-type ament_cmake tutorial_interfaces
</code></pre>
<p>采用C++开发时，新建的包稍微有些不一样，</p>
<pre><code class="language-bash">tutorial_interfaces/
     CMakeLists.txt
     include/tutorial_interfaces/
     package.xml
     src/
</code></pre>
<p>package.xml还是指定了包的依赖（依赖包的名字会不一样），src/存放源文件，include/tutorial_interfaces/存放头文件，CMakeLists.txt描述了怎么编译这个包。</p>
<p>在这个样例中我们学习怎么自定义信息和服务两种数据结构，在ros2_ws/src/tutorial_interfaces目录下再新建两个对应的目录，</p>
<pre><code class="language-bash">$ mkdir msg srv
</code></pre>
<h1 id="二-定义数据结构">二、定义数据结构</h1>
<p>如果我们要定义的数据结构是信息，那么就再tutorial_interfaces/msg目录下新建对应的文件，信息数据结构文件以.msg结尾，例如我们定义一个Num.msg，如下所示，它只有一个整型变量</p>
<pre><code class="language-bash">int64 num
</code></pre>
<p>在我们定义的数据结构中也可以引用ROS中预定义的数据结构，假如我们想定义一个球的数据结构，球需要定义球心和半径，我们就可以如下定义Sphere.msg，geometry_msgs/Point是ROS预定义的数据结构</p>
<pre><code class="language-bash">geometry_msgs/Point center
float64 radius
</code></pre>
<p>如果我们要定义的数据结构是服务，那么就再tutorial_interfaces/srv目录下新建对应的文件，服务的数据结构以.srv结尾，仿照前面服务通信用到加法服务数据结构定义3个整数的加法服务数据结构AddThreeInts.srv，</p>
<pre><code class="language-bash">int64 a
int64 b
int64 c
---
int64 sum
</code></pre>
<p>同样，上半部分是请求，下半部分是结果。</p>
<h1 id="三-更新配置文件">三、更新配置文件</h1>
<h2 id="31-cmakeliststxt">3.1、CMakeLists.txt</h2>
<p>新建包时生成的CMakeLists.txt如下所示，</p>
<pre><code class="language-bash">cmake_minimum_required(VERSION 3.8)
project(tutorial_interfaces)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES &quot;Clang&quot;)
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# find dependencies
find_package(ament_cmake REQUIRED)
# uncomment the following section in order to fill in
# further dependencies manually.
# find_package(&lt;dependency&gt; REQUIRED)

if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  # the following line skips the linter which checks for copyrights
  # comment the line when a copyright and license is added to all source files
  set(ament_cmake_copyright_FOUND TRUE)
  # the following line skips cpplint (only works in a git repo)
  # comment the line when this package is in a git repo and when
  # a copyright and license is added to all source files
  set(ament_cmake_cpplint_FOUND TRUE)
  ament_lint_auto_find_test_dependencies()
endif()

ament_package()

</code></pre>
<p>我们的球数据结构Sphere.msg依赖geometry_msgs包，同时我们还需要调用rosidl_default_generators来把我们自定义是数据结构转换成语言相关的代码，默认的生成器应该包含了C++和Python两种语言。最后，调用rosidl_generate_interfaces()生成对应的接口，</p>
<pre><code class="language-bash">find_package(geometry_msgs REQUIRED)
find_package(rosidl_default_generators REQUIRED)

rosidl_generate_interfaces(${PROJECT_NAME}
  &quot;msg/Num.msg&quot;
  &quot;msg/Sphere.msg&quot;
  &quot;srv/AddThreeInts.srv&quot;
  DEPENDENCIES geometry_msgs # Add packages that above messages depend on, in this case geometry_msgs for Sphere.msg
)
</code></pre>
<h2 id="32-packagexml">3.2、package.xml</h2>
<p>package.xml增加如下代码，</p>
<pre><code class="language-xml">&lt;depend&gt;geometry_msgs&lt;/depend&gt; # Sphere.msg依赖该包
&lt;buildtool_depend&gt;rosidl_default_generators&lt;/buildtool_depend&gt; # 用于生成语言相关的代码
&lt;exec_depend&gt;rosidl_default_runtime&lt;/exec_depend&gt; # 这是使用自定义接口需要的运行时
&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt; # 我们的接口是关联到这个包的
</code></pre>
<h1 id="四-编译与验证">四、编译与验证</h1>
<p>编译</p>
<pre><code class="language-bash">$ colcon build --packages-select tutorial_interfaces
</code></pre>
<p>验证</p>
<pre><code class="language-bash">$ source install/setup.bash
</code></pre>
<pre><code class="language-bash">$ ros2 interface show tutorial_interfaces/msg/Num
int64 num
</code></pre>
<pre><code class="language-bash">$ ros2 interface show tutorial_interfaces/msg/Sphere
geometry_msgs/Point center
        float64 x
        float64 y
        float64 z
float64 radius
</code></pre>
<pre><code class="language-bash">$ ros2 interface show tutorial_interfaces/srv/AddThreeInts
int64 a
int64 b
int64 c
---
int64 sum
</code></pre>
<h2 id="41-在发布订阅者通信中验证">4.1、在发布/订阅者通信中验证</h2>
<p>回到我们的发布/订阅者通信开发样例中，按如下修改代码，我们发布的主题不再使用预定义的String类型，而是简单发布一个数字，用我们自定义的Num.msg类型，</p>
<p>发布者代码修改如下，</p>
<pre><code class="language-python">import rclpy
from rclpy.node import Node

from tutorial_interfaces.msg import Num                            # CHANGE


class MinimalPublisher(Node):

    def __init__(self):
        super().__init__('minimal_publisher')
        self.publisher_ = self.create_publisher(Num, 'topic', 10)  # CHANGE
        timer_period = 0.5
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = Num()                                                # CHANGE
        msg.num = self.i                                           # CHANGE
        self.publisher_.publish(msg)
        self.get_logger().info('Publishing: &quot;%d&quot;' % msg.num)       # CHANGE
        self.i += 1


def main(args=None):
    rclpy.init(args=args)

    minimal_publisher = MinimalPublisher()

    rclpy.spin(minimal_publisher)

    minimal_publisher.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
</code></pre>
<p>订阅者代码修改如下，</p>
<pre><code class="language-python">import rclpy
from rclpy.node import Node

from tutorial_interfaces.msg import Num                        # CHANGE


class MinimalSubscriber(Node):

    def __init__(self):
        super().__init__('minimal_subscriber')
        self.subscription = self.create_subscription(
            Num,                                               # CHANGE
            'topic',
            self.listener_callback,
            10)
        self.subscription

    def listener_callback(self, msg):
            self.get_logger().info('I heard: &quot;%d&quot;' % msg.num)  # CHANGE


def main(args=None):
    rclpy.init(args=args)

    minimal_subscriber = MinimalSubscriber()

    rclpy.spin(minimal_subscriber)

    minimal_subscriber.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
</code></pre>
<p>我们还需要在package.xml添加依赖</p>
<pre><code class="language-xml">&lt;exec_depend&gt;tutorial_interfaces&lt;/exec_depend&gt;
</code></pre>
<p>最后，重新编译运行</p>
<pre><code class="language-bash">$ colcon build --packages-select py_pubsub
</code></pre>
<pre><code class="language-bash">$ ros2 run py_pubsub talker
[INFO] [minimal_publisher]: Publishing: '0'
[INFO] [minimal_publisher]: Publishing: '1'
[INFO] [minimal_publisher]: Publishing: '2'
</code></pre>
<pre><code class="language-bash">$ ros2 run py_pubsub listener
...
</code></pre>
<h2 id="42-在服务通信中验证">4.2、在服务通信中验证</h2>
<p>代码修改如下</p>
<p>服务端</p>
<pre><code class="language-python">from tutorial_interfaces.srv import AddThreeInts        # CHANGE

import rclpy
from rclpy.node import Node


class MinimalService(Node):

    def __init__(self):
        super().__init__('minimal_service')
        self.srv = self.create_service(AddThreeInts, 'add_three_ints', self.add_three_ints_callback)     # CHANGE

    def add_three_ints_callback(self, request, response):
        response.sum = request.a + request.b + request.c        # CHANGE
        self.get_logger().info('Incoming request\na: %d b: %d c: %d' % (request.a, request.b, request.c))  # CHANGE

        return response

def main(args=None):
    rclpy.init(args=args)

    minimal_service = MinimalService()

    rclpy.spin(minimal_service)

    rclpy.shutdown()

if __name__ == '__main__':
    main()
</code></pre>
<p>客户端</p>
<pre><code class="language-python">from tutorial_interfaces.srv import AddThreeInts                            # CHANGE
import sys
import rclpy
from rclpy.node import Node


class MinimalClientAsync(Node):

    def __init__(self):
        super().__init__('minimal_client_async')
        self.cli = self.create_client(AddThreeInts, 'add_three_ints')       # CHANGE
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('service not available, waiting again...')
        self.req = AddThreeInts.Request()            # CHANGE

    def send_request(self):
        self.req.a = int(sys.argv[1])
        self.req.b = int(sys.argv[2])
        self.req.c = int(sys.argv[3])              # CHANGE
        self.future = self.cli.call_async(self.req)


def main(args=None):
    rclpy.init(args=args)

    minimal_client = MinimalClientAsync()
    minimal_client.send_request()

    while rclpy.ok():
        rclpy.spin_once(minimal_client)
        if minimal_client.future.done():
            try:
                response = minimal_client.future.result()
            except Exception as e:
                minimal_client.get_logger().info(
                    'Service call failed %r' % (e,))
            else:
                minimal_client.get_logger().info(
                    'Result of add_three_ints: for %d + %d + %d = %d' %                                # CHANGE
                    (minimal_client.req.a, minimal_client.req.b, minimal_client.req.c, response.sum))  # CHANGE
            break

    minimal_client.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
</code></pre>
<p>添加依赖</p>
<pre><code class="language-xml">&lt;exec_depend&gt;tutorial_interfaces&lt;/exec_depend&gt;
</code></pre>
<p>编译运行</p>
<pre><code class="language-bash">$ colcon build --packages-select py_srvcli
</code></pre>
<pre><code class="language-bash">$ ros2 run py_srvcli service
</code></pre>
<pre><code class="language-bash">$ ros2 run py_srvcli client 2 3 1
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ROS2开发笔记——service样例（三）]]></title>
        <id>https://chenjie04.github.io/post/ros2-kai-fa-bi-ji-service-yang-li/</id>
        <link href="https://chenjie04.github.io/post/ros2-kai-fa-bi-ji-service-yang-li/">
        </link>
        <updated>2023-05-17T00:49:32.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://docs.ros.org/en/humble/_images/Service-SingleServiceClient.gif" alt="" loading="lazy"></figure>
<h1 id="一-创建包">一、创建包</h1>
<p>服务的通信方式就是客户端发起其服务请求，服务端收到请求后响应。在这里，我们通过一个加法求解的样例演示怎么进行服务开发，客户端发起请求——“我想知道a+b=？”，服务端收到a和b这两个数后把它们相加并返回给客户端。根据问题的定义，那么这个服务的数据结构就应该如下所示，</p>
<pre><code class="language-bash">int64 a
int64 b
---
int64 sum
</code></pre>
<p>上半部定义了请求的两个整型变量，下半部定义响应结果。该数据结构定义在了example_interfaces包里面，就是为了方便我们学习，后面我们也会学习怎么自定义需要的各类数据结构。</p>
<p>除了上述的数据结构包，我们还需要依赖rclpy这个包，知道了这些信息，我们就可以在新建包的时候指定这些依赖包，</p>
<pre><code class="language-bash">$ ros2 pkg create --build-type ament_python py_srvcli --dependencies rclpy example_interfaces
</code></pre>
<p>更新package.xml和setup.py中的信息，</p>
<pre><code class="language-bash">&lt;description&gt;Python client server tutorial&lt;/description&gt;
&lt;maintainer email=&quot;you@email.com&quot;&gt;Your Name&lt;/maintainer&gt;
&lt;license&gt;Apache License 2.0&lt;/license&gt;
</code></pre>
<pre><code class="language-bash">maintainer='Your Name',
maintainer_email='you@email.com',
description='Python client server tutorial',
license='Apache License 2.0',
</code></pre>
<h1 id="二-编写服务端节点">二、编写服务端节点</h1>
<p>在ros2_ws/src/py_srvcli/py_srvcli目录下创建一个service_member_function.py文件，</p>
<pre><code class="language-python">from example_interfaces.srv import AddTwoInts # 数据结构类型

import rclpy # ROS2 python客户端
from rclpy.node import Node # 节点父类


class MinimalService(Node):

    def __init__(self):
        super().__init__('minimal_service')
        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback) # 创建服务

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info('Incoming request\na: %d b: %d' % (request.a, request.b))

        return response


def main():
    rclpy.init()

    minimal_service = MinimalService()

    rclpy.spin(minimal_service)

    rclpy.shutdown()


if __name__ == '__main__':
    main()
</code></pre>
<p>我们在创建包的时候已经指定了依赖，所以现在我们只需要给程序添加执行入口，</p>
<pre><code class="language-python">entry_points={
    'console_scripts': [
        'service = py_srvcli.service_member_function:main',
    ],
},
</code></pre>
<h1 id="三-编写客户端节点">三、编写客户端节点</h1>
<p>在ros2_ws/src/py_srvcli/py_srvcli目录下创建一个client_member_function.py文件，</p>
<pre><code class="language-python">import sys # 导入sys，以便能够通过sys.argv在命令行读取输入

from example_interfaces.srv import AddTwoInts
import rclpy
from rclpy.node import Node


class MinimalClientAsync(Node):

    def __init__(self):
        super().__init__('minimal_client_async')
        self.cli = self.create_client(AddTwoInts, 'add_two_ints') # 创建客户端，注意服务的名字和类型要和上面服务端的一致
        while not self.cli.wait_for_service(timeout_sec=1.0): # 检查客户端指定的服务是否可用，如果先启动客户端节点，再启动服务端节点，就会出现服务不可用的情况，命令行提示等待
            self.get_logger().info('service not available, waiting again...')
        self.req = AddTwoInts.Request()

    def send_request(self, a, b): # 定义怎么发送请求
        self.req.a = a
        self.req.b = b
        self.future = self.cli.call_async(self.req) # 异步请求(非阻塞)
        rclpy.spin_until_future_complete(self, self.future) # 等待服务端应答
        return self.future.result()


def main():
    rclpy.init()

    minimal_client = MinimalClientAsync()
    response = minimal_client.send_request(int(sys.argv[1]), int(sys.argv[2])) # 从命令行读取输入，并发送服务请求
    minimal_client.get_logger().info(
        'Result of add_two_ints: for %d + %d = %d' %
        (int(sys.argv[1]), int(sys.argv[2]), response.sum))

    minimal_client.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
</code></pre>
<p>添加程序执行入口，</p>
<pre><code class="language-python">entry_points={
    'console_scripts': [
        'service = py_srvcli.service_member_function:main',
        'client = py_srvcli.client_member_function:main',
    ],
},
</code></pre>
<h1 id="四-编译与运行">四、编译与运行</h1>
<p>检查依赖，</p>
<pre><code class="language-bash">$ rosdep install -i --from-path src --rosdistro humble -y
</code></pre>
<p>编译</p>
<pre><code class="language-bash">$ colcon build --packages-select py_srvcli
</code></pre>
<p>启动服务端</p>
<pre><code class="language-bash">$ source install/setup.bash
$ ros2 run py_srvcli service
</code></pre>
<p>在新的终端启动客户端</p>
<pre><code class="language-bash">$ source install/setup.bash
$ ros2 run py_srvcli client 2 3
[INFO] [minimal_client_async]: Result of add_two_ints: for 2 + 3 = 5
</code></pre>
<p>回到服务端窗口，我们可以看到刚刚输出了以下提示信息，</p>
<pre><code class="language-bash">[INFO] [minimal_service]: Incoming request
a: 2 b: 3
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ROS2开发笔记——Topic样例（二）]]></title>
        <id>https://chenjie04.github.io/post/ros-kai-fa-bi-ji/</id>
        <link href="https://chenjie04.github.io/post/ros-kai-fa-bi-ji/">
        </link>
        <updated>2023-05-16T08:13:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-新建工作空间">一、新建工作空间</h1>
<p>ROS采用工作空间的概念，在工作空间目录下一般设src目录存放源代码。ROS采用包的形式管理项目，所有工作空间src目录下一般有多个包。ROS可以采用python或C++进行开发，也可以同时采用这两种语言混合开发，因此一个典型ROS工作空间如下所示，</p>
<pre><code class="language-bash">workspace_folder/
    src/
      cpp_package_1/
          CMakeLists.txt
          include/cpp_package_1/
          package.xml
          src/

      py_package_1/
          package.xml
          resource/py_package_1
          setup.cfg
          setup.py
          py_package_1/
      ...
      cpp_package_n/
          CMakeLists.txt
          include/cpp_package_n/
          package.xml
          src/
</code></pre>
<p>下面，我们新建自己的工作空间，</p>
<pre><code class="language-bash">$ mkdir -p ~/ros2_ws/src
$ cd  ~/ros2_ws/src
</code></pre>
<h1 id="二-新建包">二、新建包</h1>
<p>ROS 提供了工具帮助我们按照模板新建包，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>b</mi><mi>u</mi><mi>i</mi><mi>l</mi><mi>d</mi><mo>−</mo><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;build-type&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span> 指定了编译类型，也就是指定了我们使用什么语言进行开发，使用C++则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>b</mi><mi>u</mi><mi>i</mi><mi>l</mi><mi>d</mi><mo>−</mo><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;build-type&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>为 ament_cmake， 而使用python则是ament_python。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>p</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>a</mi><mi>g</mi><msub><mi>e</mi><mi>n</mi></msub><mi>a</mi><mi>m</mi><mi>e</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;package_name&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>是我们的包名字。</p>
<pre><code class="language-bash">ros2 pkg create --build-type &lt;build-type&gt; &lt;package_name&gt;
</code></pre>
<p>下面，我们新建一个py_pubsub包，学习使用python进行ROS主题通信的开发，</p>
<pre><code class="language-bash">$ ros2 pkg create --build-type ament_python py_pubsub
</code></pre>
<p>我们看一下新建的py_pubsub的目录结构，</p>
<pre><code class="language-bash">py_pubsub/
      py_pubsub/
      resource/py_pubsub
      test/
      package.xml
      setup.cfg
      setup.py
</code></pre>
<h2 id="21-packagexml">2.1、package.xml</h2>
<p>首先，查看第一个package.xml文件，首先它包含了一些包的名字、版本号、描述信息、许可以及维护者的信息。更重要的是package.xml指定了这个包的依赖，方便编译器在编译的时候能够找到对应的依赖。依赖以_depend结尾的标签指定，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>t</mi><mi>e</mi><mi>s</mi><msub><mi>t</mi><mi>d</mi></msub><mi>e</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>d</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;test_depend&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>顾名思义是测试时用到的依赖，还有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>b</mi><mi>u</mi><mi>i</mi><mi>l</mi><msub><mi>d</mi><mi>d</mi></msub><mi>e</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>d</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;build_depend&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>编译依赖，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>e</mi><mi>x</mi><mi>e</mi><msub><mi>c</mi><mi>d</mi></msub><mi>e</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>d</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;exec_depend&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>执行依赖，以及<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>b</mi><mi>u</mi><mi>i</mi><mi>l</mi><msub><mi>d</mi><mi>e</mi></msub><mi>x</mi><mi>p</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mi>d</mi></msub><mi>e</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>d</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;build_export_depend&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>导出依赖等。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;?xml-model
   href=&quot;http://download.ros.org/schema/package_format3.xsd&quot;
   schematypens=&quot;http://www.w3.org/2001/XMLSchema&quot;?&gt;
&lt;package format=&quot;3&quot;&gt;
 &lt;name&gt;py_pubsub&lt;/name&gt;
 &lt;version&gt;0.0.0&lt;/version&gt;
 &lt;description&gt;TODO: Package description&lt;/description&gt;
 &lt;maintainer email=&quot;user@todo.todo&quot;&gt;user&lt;/maintainer&gt;
 &lt;license&gt;TODO: License declaration&lt;/license&gt;

 &lt;test_depend&gt;ament_copyright&lt;/test_depend&gt;
 &lt;test_depend&gt;ament_flake8&lt;/test_depend&gt;
 &lt;test_depend&gt;ament_pep257&lt;/test_depend&gt;
 &lt;test_depend&gt;python3-pytest&lt;/test_depend&gt;

 &lt;export&gt;
   &lt;build_type&gt;ament_python&lt;/build_type&gt;
 &lt;/export&gt;
&lt;/package&gt;
</code></pre>
<p>加入我们项目中需要用到一个包，但是我们系统上没有，那么编译的时候必然会报错，那么我们怎么安装这些外部依赖包呢？这需要用到rosdep这个工具。使用rosdep之前，需要先对它进行初始化并更新，</p>
<pre><code class="language-bash">$ sudo rosdep init
$ rosdep update
</code></pre>
<p>但是sudo rosdep init需要从GitHub下载数据，由于国内的原因，运行这个命令必然会失败。这成为了每个学习ros的人必然要面对的一个问题。国情原因我理解，只是不知道为什么国内ros社区没有去维护一个国内版本，可能是许可的原因吧，以致大家需要使用一些邪魔外道的手段才可以解决这个问题。</p>
<p>不过，现在博主鱼香ROS，自己维护了国内版<a href="https://zhuanlan.zhihu.com/p/398754989">rosdepc</a>，算是解决了这个问题，rosdepc的安装与使用</p>
<pre><code class="language-bash">$ pip install rosdepc
$ rosdepc init
$ rosdepc update
</code></pre>
<p>检查并安装依赖，</p>
<pre><code class="language-bash">rosdepc install --from-paths src -y --ignore-src
</code></pre>
<p>--from-paths src 表示检查src目录下的package.xml中的依赖，-y就是默认yes，--ignore-src表示加入package.xml中指定的某个依赖是当前工作空间中的就忽略，因为编译之后必然会安装。</p>
<h2 id="22-setuppy">2.2、setup.py</h2>
<p>setup.py是python包的安装指令文件，指定了怎么安装这个包，同样也包含该包的一些相关信息，我们需要注意的是执行程序入口entry_points，示例中定义了一个执行程序入口为my_node，该入口指向my_py_pkg.my_node:main函数，后面写代码的时候会有具体示例。</p>
<pre><code class="language-python">from setuptools import setup

package_name = 'py_pubsub'

setup(
 name=package_name,
 version='0.0.0',
 packages=[package_name],
 data_files=[
     ('share/ament_index/resource_index/packages',
             ['resource/' + package_name]),
     ('share/' + package_name, ['package.xml']),
   ],
 install_requires=['setuptools'],
 zip_safe=True,
 maintainer='TODO',
 maintainer_email='TODO',
 description='TODO: Package description',
 license='TODO: License declaration',
 tests_require=['pytest'],
 entry_points={
     'console_scripts': [
            # 'my_node = my_py_pkg.my_node:main'
     ],
   },
)
</code></pre>
<h2 id="23-setupcfg">2.3、setup.cfg</h2>
<p>setup.cfg是为了执行ros2 run命令时能够找到对应的可执行程序，</p>
<pre><code class="language-cfg">[develop]
script_dir=$base/lib/py_pubsub
[install]
install_scripts=$base/lib/py_pubsub

</code></pre>
<h2 id="24-其他">2.4、其他</h2>
<p>剩下的是三个目录，一个是跟包同名的目录，用于存放我们的源代码文件，该目录下还有__init__.py文件。另外一个是resource目录，底下也是跟包同名的目录，用于存放相关资源文件，比如图片啥的。最后就是自动的测试脚本了，暂时不用管。</p>
<h1 id="三-编写publisher节点">三、编写publisher节点</h1>
<p>在源代码的存放目录新建一个名为publisher_member_function.py的python文件，publisher节点示例如下，</p>
<pre><code class="language-python">import rclpy # ROS提供的python接口
from rclpy.node import Node  # 应该是ROS节点的父类了

from std_msgs.msg import String # 从标准信息类型库中导入字符串类型，其实就是数据类型


class MinimalPublisher(Node): # 定义类并继承Node

    def __init__(self):
        super().__init__('minimal_publisher')
        self.publisher_ = self.create_publisher(String, 'topic', 10) # 创建一个发布者，该发布者在一个名为'topic'（可以定义为其他名字）的主题上发布一个String类型的信息，10表示缓冲队列的大小，队列大小是一项必需的 QoS（服务质量）设置，如果订阅者接收消息的速度不够快，它会限制排队消息的数量。
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback) # 创建一个计时器，该计时器按一定时间间隔（0.5秒）调用回调函数self.timer_callback
        self.i = 0

    def timer_callback(self): # 回调函数，构造并发布信息
        msg = String()
        msg.data = 'Hello World: %d' % self.i
        self.publisher_.publish(msg) # 发布信息（这是给订阅者发布的）
        self.get_logger().info('Publishing: &quot;%s&quot;' % msg.data) # 同时还发布到终端 console
        self.i += 1


def main(args=None):
    rclpy.init(args=args) # 初始化节点

    minimal_publisher = MinimalPublisher() # 实例化发布者节点

    rclpy.spin(minimal_publisher) # 启动发布者节点

    # Destroy the node explicitly
    # (optional - otherwise it will be done automatically
    # when the garbage collector destroys the node object)
    minimal_publisher.destroy_node() # 销毁发布者节点
    rclpy.shutdown() # 关闭节点


if __name__ == '__main__':
    main()
</code></pre>
<p>因为我们在发布者节点中调用了两个库：rclpy和std_msgs，这两个库是运行时需要的，数据执行依赖，所以我们打开这个包下的package.xml文件，添加以下两行，</p>
<pre><code class="language-xml">&lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;
&lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;
</code></pre>
<p>然后，我们需要为程序调用定义入口，打开setup.py文件，添加如下代码，</p>
<pre><code class="language-python">entry_points={
        'console_scripts': [
                'talker = py_pubsub.publisher_member_function:main',
        ],
},
</code></pre>
<p>其中，talker是自定义的名字，调用时如下所示，</p>
<pre><code class="language-bash">$ ros2 run py_pubsub talker
</code></pre>
<h1 id="四-编写subscriber节点">四、编写subscriber节点</h1>
<p>该节点简单接受publisher发布的信息并打印到终端，</p>
<pre><code class="language-python">import rclpy
from rclpy.node import Node

from std_msgs.msg import String


class MinimalSubscriber(Node):

    def __init__(self):
        super().__init__('minimal_subscriber')
        self.subscription = self.create_subscription(
            String,
            'topic',
            self.listener_callback,
            10) # 新建订阅者，接收'topic'的数据并调用self.listener_callback函数
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info('I heard: &quot;%s&quot;' % msg.data) # 打印到终端


def main(args=None):
    rclpy.init(args=args)

    minimal_subscriber = MinimalSubscriber()

    rclpy.spin(minimal_subscriber)

    # Destroy the node explicitly
    # (optional - otherwise it will be done automatically
    # when the garbage collector destroys the node object)
    minimal_subscriber.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
</code></pre>
<p>由于它和发布者程序调用的依赖是一样的，所以我们不需要再一次添加依赖，但是需要给它添加执行入口，打开setup.py，按如下所示添加，</p>
<pre><code class="language-python">entry_points={
        'console_scripts': [
                'talker = py_pubsub.publisher_member_function:main',
                'listener = py_pubsub.subscriber_member_function:main',
        ],
},
</code></pre>
<h1 id="五-编译与运行">五、编译与运行</h1>
<p>按照惯例，编译前检查一下依赖，</p>
<pre><code class="language-bash">$ rosdepc install -i --from-path src --rosdistro humble -y
</code></pre>
<p>rosdepc可以自定义很多参数，我们看到多少学多少，这里--rosdistro humble是指定ROS版本，不指定也行，这是多版本混合开发才需要的。</p>
<p>ROS2采用的编译器是colcon，回到工作空间的根目录ros2_ws，执行编译，</p>
<pre><code class="language-bash">$ colcon build --packages-select py_pubsub
</code></pre>
<p>--packages-select py_pubsub是指定只编译py_pubsub，如果不指定，直接执行colcon build会编译整个工作空间中所有的包。</p>
<p>编译之后，我们会发现工作空间中多了三个目录，build/用于存放编译过程的中间文件，install/就是安装目录，就是我们把刚才的py_pubsub包安装到这里了，log/顾名思义日志文件。</p>
<pre><code class="language-bash">ros2_ws/
    build/
    install/
    log/
    src/
</code></pre>
<p>我们要使用刚编译的py_pubsub，还需要执行以下以下命令来配置环境变量，</p>
<pre><code class="language-bash">$ source install/setup.bash
</code></pre>
<p>运行发布者节点，</p>
<pre><code class="language-bash">$ ros2 run py_pubsub talker
[INFO] [minimal_publisher]: Publishing: &quot;Hello World: 0&quot;
[INFO] [minimal_publisher]: Publishing: &quot;Hello World: 1&quot;
[INFO] [minimal_publisher]: Publishing: &quot;Hello World: 2&quot;
[INFO] [minimal_publisher]: Publishing: &quot;Hello World: 3&quot;
[INFO] [minimal_publisher]: Publishing: &quot;Hello World: 4&quot;
...
</code></pre>
<p>运行订阅者节点，</p>
<pre><code class="language-bash">$ ros2 run py_pubsub listener
[INFO] [minimal_subscriber]: I heard: &quot;Hello World: 10&quot;
[INFO] [minimal_subscriber]: I heard: &quot;Hello World: 11&quot;
[INFO] [minimal_subscriber]: I heard: &quot;Hello World: 12&quot;
[INFO] [minimal_subscriber]: I heard: &quot;Hello World: 13&quot;
[INFO] [minimal_subscriber]: I heard: &quot;Hello World: 14&quot;
</code></pre>
<p>好了！至此入门ros开发第一课结束了，从开发、编译、运行整个流程都走了一遍了，下一步学习服务通信的开发！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ROS2概念学习笔记（一）]]></title>
        <id>https://chenjie04.github.io/post/ros2-gai-nian-xue-xi-bi-ji/</id>
        <link href="https://chenjie04.github.io/post/ros2-gai-nian-xue-xi-bi-ji/">
        </link>
        <updated>2023-05-11T12:48:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-节点node">一、节点（Node）</h1>
<figure data-type="image" tabindex="1"><img src="http://docs.ros.org/en/humble/_images/Nodes-TopicandService.gif" alt="" loading="lazy"></figure>
<p>节点是ROS的最小执行单元，每个节点应该只负责单一一个目的。节点之间通过主题（topic）、服务（services）、动作（actions）或参数（parameters）等方式进行通信。</p>
<p>ROS系统就是由许许多多的节点组成。</p>
<p>一个或多个节点组成一个可执行程序（C++程序，python程序等）。</p>
<p>一个或多个可行执程序组成一个包（package）。</p>
<p>例如，我们通过以下命令安装我们的第一个ROS包，也就是小海龟仿真，</p>
<pre><code class="language-bash">$ sudo apt update
$ sudo apt install ros-humble-turtlesim
</code></pre>
<p>通过以下命令查看turtlesim包有哪些可执行程序，</p>
<pre><code class="language-bash">$ ros2 pkg executables turtlesim
turtlesim draw_square
turtlesim mimic
turtlesim turtle_teleop_key
turtlesim turtlesim_node
</code></pre>
<p>回顾我们熟悉的ROS命令：</p>
<pre><code class="language-bash"># ros2 run &lt;package_name&gt; &lt;executable_name&gt;
$ ros2 run turtlesim turtlesim_node
</code></pre>
<p>其中，turtlesim是一个包，而turtlesim_node是一个可执行程序，也就是通过执行turtlesim包的turtlesim_node程序创建了一个/turtlesim。（怎么有点类和实例的味道？）</p>
<p>假如，我们想查看当前系统中运行这哪些节点，</p>
<pre><code class="language-bash">$ ros2 node list
$ /turtlesim
</code></pre>
<p>当前只运行了/turtlesim 这一个节点。在启动另外一个控制节点，</p>
<pre><code class="language-bash">$ ros2 run turtlesim turtle_teleop_key
# 查看节点
$ ros2 node list
$ /turtlesim
  /teleop_turtle
</code></pre>
<p>我们可以通过Remapping修改节点的属性，比如我们想启动一个新的/turtlesim并将名字改为/my_turtle，</p>
<pre><code class="language-bash">$ ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle
</code></pre>
<pre><code class="language-bash">$ ros2 node list
$ /my_turtle
  /turtlesim
  /teleop_turtle
</code></pre>
<p>知道节点的名字，我们就可以通过以下命令查看节点的更多信息</p>
<pre><code class="language-bash">$ ros2 node info &lt;node_name&gt;
</code></pre>
<pre><code class="language-bash">$ ros2 node info /my_turtle
$ /my_turtle
  Subscribers:
    /parameter_events: rcl_interfaces/msg/ParameterEvent
    /turtle1/cmd_vel: geometry_msgs/msg/Twist
  Publishers:
    /parameter_events: rcl_interfaces/msg/ParameterEvent
    /rosout: rcl_interfaces/msg/Log
    /turtle1/color_sensor: turtlesim/msg/Color
    /turtle1/pose: turtlesim/msg/Pose
  Service Servers:
    /clear: std_srvs/srv/Empty
    /kill: turtlesim/srv/Kill
    /my_turtle/describe_parameters: rcl_interfaces/srv/DescribeParameters
    /my_turtle/get_parameter_types: rcl_interfaces/srv/GetParameterTypes
    /my_turtle/get_parameters: rcl_interfaces/srv/GetParameters
    /my_turtle/list_parameters: rcl_interfaces/srv/ListParameters
    /my_turtle/set_parameters: rcl_interfaces/srv/SetParameters
    /my_turtle/set_parameters_atomically: rcl_interfaces/srv/SetParametersAtomically
    /reset: std_srvs/srv/Empty
    /spawn: turtlesim/srv/Spawn
    /turtle1/set_pen: turtlesim/srv/SetPen
    /turtle1/teleport_absolute: turtlesim/srv/TeleportAbsolute
    /turtle1/teleport_relative: turtlesim/srv/TeleportRelative
  Service Clients:

  Action Servers:
    /turtle1/rotate_absolute: turtlesim/action/RotateAbsolute
  Action Clients:
</code></pre>
<h1 id="二-主题topic">二、主题（topic）</h1>
<figure data-type="image" tabindex="2"><img src="https://docs.ros.org/en/humble/_images/Topic-MultiplePublisherandMultipleSubscriber.gif" alt="" loading="lazy"></figure>
<p>话题是单向消息发送/接收的一种通信方式，一个节点发送一个接受就完事。不过主题这种通信方式是一个一对一、一对多、多对一、多对多的。</p>
<p>需要引入另外一个信息（Message）的概念，信息定义了主题的数据格式。吐槽一下：主题和信息这两个数据可真是够怪异的，居然信息是数据格式，主题才是数据载体，按照我们的生活习惯应该反过来才对。Nodes send data over topics using messages.</p>
<p>例如，下面定义了小海龟姿态的信息数据格式，</p>
<pre><code class="language-python"># turtlesim/msg/Pose.msg
float32 x
float32 y
float32 theta

float32 linear_velocity
float32 angular_velocity
</code></pre>
<p>我们再次启动两个节点观察它们通信的主题，</p>
<pre><code class="language-bash">$ ros2 run turtlesim turtlesim_node
</code></pre>
<pre><code class="language-bash">$ ros2 run turtlesim turtle_teleop_key
</code></pre>
<p>然后，我们就可以通过以下命令查看</p>
<pre><code class="language-bash">$ ros2 topic list
/parameter_events
/rosout
/turtle1/cmd_vel
/turtle1/color_sensor
/turtle1/pose
</code></pre>
<p>ros2 topic list -t 会额外输出每个主题的信息类型，</p>
<pre><code class="language-bash">$ ros2 topic list -t 
/parameter_events [rcl_interfaces/msg/ParameterEvent]
/rosout [rcl_interfaces/msg/Log]
/turtle1/cmd_vel [geometry_msgs/msg/Twist]
/turtle1/color_sensor [turtlesim/msg/Color]
/turtle1/pose [turtlesim/msg/Pose]
</code></pre>
<p>打开rqt_graph程序查看节点和主题（取消隐藏复选框，另外不同版本的输出略有不同），<br>
<img src="https://docs.ros.org/en/humble/_images/unhide.png" alt="" loading="lazy"></p>
<p>为了方便debug，我们可以从终端打印主题内部的数据，</p>
<pre><code class="language-bash"># ros2 topic echo &lt;topic_name&gt;
$ ros2 topic echo /turtle1/cmd_vel
linear:
  x: 2.0
  y: 0.0
  z: 0.0
angular:
  x: 0.0
  y: 0.0
  z: 0.0
  ---
</code></pre>
<p>回到 rqt_graph并去掉debug的复选框，如果没有去掉的话，这时候我们发现多了一个节点/_ros2cli_26646订阅/turtle1/cmd_vel 这个主题。这个节点就是上面的echo命令创建的。<br>
<img src="https://docs.ros.org/en/humble/_images/debug.png" alt="" loading="lazy"></p>
<p>同样，我们可以通过以下命令查看主题的相关信息，</p>
<pre><code class="language-bash">$ ros2 topic info /turtle1/cmd_vel
Type: geometry_msgs/msg/Twist
Publisher count: 1
Subscription count: 2
</code></pre>
<p>我们知道主题对应的信息类型之后，可以查看具体数据结构，例如上面主题的信息类型为geometry_msgs/msg/Twist，表示geometry_msgs包有一个msg名为Twist，那么查看的命令为</p>
<pre><code class="language-bash">$ ros2 interface show geometry_msgs/msg/Twist
#This expresses velocity in free space broken into its linear and angular parts.

    Vector3  linear
            float64 x
            float64 y
            float64 z
    Vector3  angular
            float64 x
            float64 y
            float64 z
</code></pre>
<p>知道了主题，也知道了信息类型，那么我们在debug的时候就可以通过终端直接发布主题，如，</p>
<pre><code class="language-bash"># ros2 topic pub &lt;topic_name&gt; &lt;msg_type&gt; '&lt;args&gt;'
$ ros2 topic pub --once /turtle1/cmd_vel geometry_msgs/msg/Twist &quot;{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}&quot;
publisher: beginning loop
publishing #1: geometry_msgs.msg.Twist(linear=geometry_msgs.msg.Vector3(x=2.0, y=0.0, z=0.0), angular=geometry_msgs.msg.Vector3(x=0.0, y=0.0, z=1.8))
</code></pre>
<p>--once表示仅发布一条主题然后程序退出。我们也可以看到小海龟转了一个小弯，</p>
<figure data-type="image" tabindex="3"><img src="https://docs.ros.org/en/humble/_images/pub_once.png" alt="" loading="lazy"></figure>
<p>我们也可以以一定的频率持续发布主题，比如1Hz，</p>
<pre><code class="language-bash">$ ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist &quot;{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}&quot;
</code></pre>
<p>那么小海龟就会在转圈圈，<br>
<img src="https://docs.ros.org/en/humble/_images/pub_stream.png" alt="" loading="lazy"></p>
<p>我们可以查看某个主题的发布频率，如</p>
<pre><code class="language-bash">$ ros2 topic hz /turtle1/pose
average rate: 59.354
  min: 0.005s max: 0.027s std dev: 0.00284s window: 58
</code></pre>
<p>总结一下：主题这种通信方式就是一个节点作为发布者以一定的频率发布主题，另外一个节点作为订阅者订阅了该主题之后就可以接受这条主题，主题的内容由信息类型定义。一个节点可以作为发布者发布不同的主题，同时也可以作为订阅者订阅不同的主题。例如小海龟节点作为订阅者订阅了两条主题，同时作为发布者发布了4条主题，如下所示。</p>
<pre><code class="language-bash">$ /my_turtle
  Subscribers:
    /parameter_events: rcl_interfaces/msg/ParameterEvent
    /turtle1/cmd_vel: geometry_msgs/msg/Twist
  Publishers:
    /parameter_events: rcl_interfaces/msg/ParameterEvent
    /rosout: rcl_interfaces/msg/Log
    /turtle1/color_sensor: turtlesim/msg/Color
    /turtle1/pose: turtlesim/msg/Pose
</code></pre>
<h1 id="三-服务services">三、服务（services）</h1>
<p>上面那种主题的通信方式是发布者以固定的频率持续输出数据，而订阅者只能被动接受的单向通信。显然有些功能并不需要怎么高频率的通信。服务是以请求/响应双向通信的方式，客服端有通信需求了就想服务器发起通信请求，服务器才响应并把数据发给客户端。如下图所示，服务这种通信方式，需要有一个节点作为服务端，另外一个作为客户端，服务定义了请求和响应的数据格式。服务可以是一对一也可以是一对多。</p>
<p><img src="https://docs.ros.org/en/humble/_images/Service-SingleServiceClient.gif" alt="" loading="lazy"><br>
<img src="https://docs.ros.org/en/humble/_images/Service-MultipleServiceClient.gif" alt="" loading="lazy"></p>
<p>同样，启动两个节点看看它们启用了哪些服务通信，</p>
<pre><code class="language-bash">$ ros2 run turtlesim turtlesim_node
</code></pre>
<pre><code class="language-bash">$ ros2 run turtlesim turtle_teleop_key
</code></pre>
<p>查看激活的服务，</p>
<pre><code class="language-bash">$ ros2 service list -t
/clear [std_srvs/srv/Empty]
/kill [turtlesim/srv/Kill]
/reset [std_srvs/srv/Empty]
/spawn [turtlesim/srv/Spawn]
...
/turtle1/set_pen [turtlesim/srv/SetPen]
/turtle1/teleport_absolute [turtlesim/srv/TeleportAbsolute]
/turtle1/teleport_relative [turtlesim/srv/TeleportRelative]
...
</code></pre>
<p>不同的服务属于不同的类型，类型正是定义了请求和响应的数据格式。<br>
单独查看某个服务的类型，</p>
<pre><code class="language-bash">$ ros2 service type /clear
std_srvs/srv/Empty
</code></pre>
<p>查看某个类型下有哪些服务，</p>
<pre><code class="language-bash">$ ros2 service find std_srvs/srv/Empty
/clear
/reset
</code></pre>
<p>查看某个类型定义的数据格式，</p>
<pre><code class="language-bash">$ ros2 interface show std_srvs/srv/Empty
---
</code></pre>
<p>返回---说明该服务的请求和响应不需要发送数据。<br>
/Spawn是生成小海龟的服务，发起请求时需要给定小海龟的坐标和朝向，也可以指定小海龟的名字，服务响应之后返回小海龟的名字。</p>
<pre><code class="language-bash">$ ros2 interface show turtlesim/srv/Spawn
float32 x
float32 y
float32 theta
string name # Optional.  A unique name will be created and returned if this is empty
---
string name
</code></pre>
<p>从终端直接发起服务请求，例如请求清空小海龟的运动的轨迹，</p>
<pre><code class="language-bash"># ros2 service call &lt;service_name&gt; &lt;service_type&gt; &lt;arguments&gt;
$ ros2 service call /clear std_srvs/srv/Empty
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://docs.ros.org/en/humble/_images/clear.png" alt="" loading="lazy"></figure>
<p>请求再生成一个小海龟，</p>
<pre><code class="language-bash">$ ros2 service call /spawn turtlesim/srv/Spawn &quot;{x: 2, y: 2, theta: 0.2, name: ''}&quot;
requester: making request: turtlesim.srv.Spawn_Request(x=2.0, y=2.0, theta=0.2, name='')

response:
turtlesim.srv.Spawn_Response(name='turtle2')
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://docs.ros.org/en/humble/_images/spawn1.png" alt="" loading="lazy"></figure>
<h1 id="四-动作action">四、动作（action）</h1>
<p>动作是构建在主题和服务之上的一种通信方式，适用于那些需要长时间的任务。想象一个例子，你的老板让你给他写一个本子（动作客户端发起目的服务请求），你回好的！（动作服务端响应目的服务），接着你的老板说本子给我吧（动作客户端发起结果服务请求），但是写本子是需要时间的啊，没办法马上给他，只能给他持续的反馈（反馈主题，动作服务端是发布者，动作客户端是订阅者）：撰写进度10%……20%……80%……100%%，然后把本子甩给老板（动作服务端响应结果服务）。动作通信大概就是这么个工作方式，结合下图再理解一下，<br>
<img src="https://docs.ros.org/en/humble/_images/Action-SingleActionClient.gif" alt="" loading="lazy"></p>
<p>启动节点，</p>
<pre><code class="language-bash">$ ros2 run turtlesim turtlesim_node
</code></pre>
<pre><code class="language-bash">$ ros2 run turtlesim turtle_teleop_key
</code></pre>
<p>在启动控制节点turtle_teleop_key之后，终端出现以下提示信息，其中第二行“用G|B|V|C|D|E|R|T键旋转到绝对方向，按F键取消”这一功能就是通过动作来通信的。</p>
<pre><code class="language-bash">Use arrow keys to move the turtle.
Use G|B|V|C|D|E|R|T keys to rotate to absolute orientations. 'F' to cancel a rotation.
</code></pre>
<p>查看动作</p>
<pre><code class="language-bash">$ ros2 action list -t
/turtle1/rotate_absolute [turtlesim/action/RotateAbsolute]
</code></pre>
<p>动作名称为/turtle1/rotate_absolute，类型turtlesim/action/RotateAbsolute。</p>
<p>查看动作信息</p>
<pre><code class="language-bash">$ ros2 action info /turtle1/rotate_absolute
Action: /turtle1/rotate_absolute
Action clients: 1
    /teleop_turtle
Action servers: 1
    /turtlesim
</code></pre>
<p>查看动作通信的数据结构</p>
<pre><code class="language-bash">$ ros2 interface show turtlesim/action/RotateAbsolute
# The desired heading in radians
float32 theta
---
# The angular displacement in radians to the starting position
float32 delta
---
# The remaining rotation in radians
float32 remaining
</code></pre>
<p>第一部分是目的服务的数据结构，第二部分是结果服务的数据结构，第三部分是反馈主题的数据结构。</p>
<p>从终端发送目的命令</p>
<pre><code class="language-bash"># ros2 action send_goal &lt;action_name&gt; &lt;action_type&gt; &lt;values&gt;
$ ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute &quot;{theta: -1.57}&quot; --feedback

Sending goal:
   theta: -1.57

Goal accepted with ID: e6092c831f994afda92f0086f220da27

Feedback:
  remaining: -3.1268222332000732

Feedback:
  remaining: -3.1108222007751465

…

Result:
  delta: 3.1200008392333984

Goal finished with status: SUCCEEDED
</code></pre>
<h1 id="五-参数parameter">五、参数（parameter）</h1>
<p>参数就是节点的配置信息，在生成节点的时候需要进行读取。</p>
<p>启动节点，</p>
<pre><code class="language-bash">$ ros2 run turtlesim turtlesim_node
</code></pre>
<pre><code class="language-bash">$ ros2 run turtlesim turtle_teleop_key
</code></pre>
<p>查看各个节点的参数，</p>
<pre><code class="language-bash">$ ros2 param list
/teleop_turtle:
  qos_overrides./parameter_events.publisher.depth
  qos_overrides./parameter_events.publisher.durability
  qos_overrides./parameter_events.publisher.history
  qos_overrides./parameter_events.publisher.reliability
  scale_angular
  scale_linear
  use_sim_time
/turtlesim:
  background_b
  background_g
  background_r
  qos_overrides./parameter_events.publisher.depth
  qos_overrides./parameter_events.publisher.durability
  qos_overrides./parameter_events.publisher.history
  qos_overrides./parameter_events.publisher.reliability
  use_sim_time
</code></pre>
<p>获取特定节点的特定参数，</p>
<pre><code class="language-bash"># ros2 param get &lt;node_name&gt; &lt;parameter_name&gt;
$ ros2 param get /turtlesim background_g
Integer value is: 86
</code></pre>
<p>设置定节点的特定参数，</p>
<pre><code class="language-bash"># ros2 param set &lt;node_name&gt; &lt;parameter_name&gt; &lt;value&gt;
$ ros2 param set /turtlesim background_r 150
Set parameter successful
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://docs.ros.org/en/humble/_images/set.png" alt="" loading="lazy"></figure>
<p>保存某个节点的参数到文件</p>
<pre><code class="language-bash"># ros2 param dump &lt;node_name&gt;
$ ros2 param dump /turtlesim &gt; turtlesim.yaml
/turtlesim:
ros__parameters:
  background_b: 255
  background_g: 86
  background_r: 150
  qos_overrides:
    /parameter_events:
      publisher:
        depth: 1000
        durability: volatile
        history: keep_last
        reliability: reliable
  use_sim_time: false
</code></pre>
<p>从配置文件中加载参数到节点，</p>
<pre><code class="language-bash"># ros2 param load &lt;node_name&gt; &lt;parameter_file&gt;
$ ros2 param load /turtlesim turtlesim.yaml
Set parameter background_b successful
Set parameter background_g successful
Set parameter background_r successful
Set parameter qos_overrides./parameter_events.publisher.depth failed: parameter 'qos_overrides./parameter_events.publisher.depth' cannot be set because it is read-only
Set parameter qos_overrides./parameter_events.publisher.durability failed: parameter 'qos_overrides./parameter_events.publisher.durability' cannot be set because it is read-only
Set parameter qos_overrides./parameter_events.publisher.history failed: parameter 'qos_overrides./parameter_events.publisher.history' cannot be set because it is read-only
Set parameter qos_overrides./parameter_events.publisher.reliability failed: parameter 'qos_overrides./parameter_events.publisher.reliability' cannot be set because it is read-only
Set parameter use_sim_time successful
</code></pre>
<p>在节点启动时加载配置文件中的参数，</p>
<pre><code class="language-bash"># ros2 run &lt;package_name&gt; &lt;executable_name&gt; --ros-args --params-file &lt;file_name&gt;
$ ros2 run turtlesim turtlesim_node --ros-args --params-file turtlesim.yaml
</code></pre>
<h1 id="六-查阅日志">六、查阅日志</h1>
<p>rqt_console是一个日志查看工具,</p>
<pre><code class="language-bash">$ ros2 run rqt_console rqt_console
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://docs.ros.org/en/humble/_images/console.png" alt="" loading="lazy"></figure>
<h1 id="七-记录并回放实验数据">七、记录并回放实验数据</h1>
<p>ROS是通过bag这个包记录并回放实验数据的，不过好像只能记录主题数据。</p>
<p>安装bag包</p>
<pre><code class="language-bash">$ sudo apt-get install ros-humble-ros2bag \
                     ros-humble-rosbag2-storage-default-plugins
</code></pre>
<p>启动节点</p>
<pre><code class="language-bash">$ ros2 run turtlesim turtlesim_node
</code></pre>
<pre><code class="language-bash">$ ros2 run turtlesim turtle_teleop_key
</code></pre>
<p>控制节点中使用方向键移动小海龟（Use arrow keys to move the turtle）就是通过主题/turtle1/cmd_vel实现的，/turtle1/cmd_vel的信息类型为 geometry_msgs/msg/Twist，数据格式如下，</p>
<pre><code class="language-bash">linear:
  x: 2.0
  y: 0.0
  z: 0.0
angular:
  x: 0.0
  y: 0.0
  z: 0.0
  ---
</code></pre>
<p>解释：Consider that you are in some space, then there are 3 axes - x, y and z which are mutually perpendicular to each other and their point of intersection is called the origin (x = 0, y = 0, z = 0). This can be a frame of reference i.e. you can define various points and directions w.r.t. them.</p>
<p>The x, y, and z in Twist.linear are the linear velocities in x, y and z directions w.r.t. that frame of reference.</p>
<p>Similarly, the x, y, and z in Twist.angular are the angular velocities about the x, y and z directions respectively w.r.t. the same frame of reference.</p>
<p>Since you have a ground robot, most probably your angular velocity will be in z i.e. robot's turning speed. And your linear velocity will be mostly in x i.e. robot's moving straight speed. This is the case for the Turtlebot 2 at least.</p>
<p>/turtle1/cmd_vel 主题可以控制小海龟的速度和方向。同时，我们一般还会记录小海龟是姿态/turtle1/pose，</p>
<p>记录示例，</p>
<pre><code class="language-bash">$ mkdir bag_files
$ cd bag_files
$ ros2 bag record -o subset /turtle1/cmd_vel /turtle1/pose
</code></pre>
<p>-o指定记录名字（bag_file_name），Ctrl+C停止记录</p>
<p>查看记录信息</p>
<pre><code class="language-bash">$ ros2 bag info subset
Files:             subset.db3
Bag size:          228.5 KiB
Storage id:        sqlite3
Duration:          48.47s
Start:             Oct 11 2019 06:09:09.12 (1570799349.12)
End                Oct 11 2019 06:09:57.60 (1570799397.60)
Messages:          3013
Topic information: Topic: /turtle1/cmd_vel | Type: geometry_msgs/msg/Twist | Count: 9 | Serialization Format: cdr
                 Topic: /turtle1/pose | Type: turtlesim/msg/Pose | Count: 3004 | Serialization Format: cdr
</code></pre>
<p>记录回放</p>
<pre><code class="language-bash">$ ros2 bag play subset
[INFO] [rosbag2_storage]: Opened database 'subset'.
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://docs.ros.org/en/humble/_images/playback.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Simple Baseline for Image Restoration]]></title>
        <id>https://chenjie04.github.io/post/simple-baseline-for-image-restoration/</id>
        <link href="https://chenjie04.github.io/post/simple-baseline-for-image-restoration/">
        </link>
        <updated>2023-04-22T08:09:36.000Z</updated>
        <content type="html"><![CDATA[<p>配置文件</p>
<pre><code class="language-python">default_scope = 'mmedit'
save_dir = './work_dirs/'
default_hooks = dict(
    timer=dict(type='IterTimerHook'),
    logger=dict(type='LoggerHook', interval=100),
    param_scheduler=dict(type='ParamSchedulerHook'),
    checkpoint=dict(
        type='CheckpointHook',
        interval=5000,
        out_dir='./work_dirs/',
        by_epoch=False,
        max_keep_ckpts=10,
        save_best='PSNR',
        rule='greater',
        save_optimizer=True),
    sampler_seed=dict(type='DistSamplerSeedHook'))
env_cfg = dict(
    cudnn_benchmark=False,
    mp_cfg=dict(mp_start_method='fork', opencv_num_threads=4),
    dist_cfg=dict(backend='nccl'))
log_level = 'INFO'
log_processor = dict(type='EditLogProcessor', window_size=100, by_epoch=False)
load_from = None
resume = False
vis_backends = [dict(type='LocalVisBackend')]
visualizer = dict(
    type='ConcatImageVisualizer',
    vis_backends=[dict(type='LocalVisBackend')],
    fn_key='gt_path',
    img_keys=['gt_img', 'input', 'pred_img'],
    bgr2rgb=False)
custom_hooks = [dict(type='BasicVisualizationHook', interval=1)]
experiment_name = 'nafnet_c64eb11128mb1db1111_lr1e-3_400k_gopro'
work_dir = './work_dirs/nafnet_c64eb11128mb1db1111_lr1e-3_400k_gopro'
model = dict(
    type='BaseEditModel',
    generator=dict(
        type='NAFNetLocal',
        img_channels=3,
        mid_channels=64,
        enc_blk_nums=[1, 1, 1, 28],
        middle_blk_num=1,
        dec_blk_nums=[1, 1, 1, 1]),
    pixel_loss=dict(type='PSNRLoss'),
    train_cfg=dict(),
    test_cfg=dict(),
    data_preprocessor=dict(
        type='EditDataPreprocessor',
        mean=[0.0, 0.0, 0.0],
        std=[255.0, 255.0, 255.0]))
train_pipeline = [
    dict(type='LoadImageFromFile', key='img'),
    dict(type='LoadImageFromFile', key='gt'),
    dict(type='SetValues', dictionary=dict(scale=1)),
    dict(
        type='Flip',
        keys=['img', 'gt'],
        flip_ratio=0.5,
        direction='horizontal'),
    dict(
        type='Flip', keys=['img', 'gt'], flip_ratio=0.5, direction='vertical'),
    dict(type='RandomTransposeHW', keys=['img', 'gt'], transpose_ratio=0.5),
    dict(type='PairedRandomCrop', gt_patch_size=256),
    dict(type='PackEditInputs')
]
val_pipeline = [
    dict(type='LoadImageFromFile', key='img', channel_order='rgb'),
    dict(type='LoadImageFromFile', key='gt', channel_order='rgb'),
    dict(type='PackEditInputs')
]
dataset_type = 'BasicImageDataset'
train_dataloader = dict(
    num_workers=8,
    batch_size=8,
    persistent_workers=False,
    sampler=dict(type='InfiniteSampler', shuffle=True),
    dataset=dict(
        type='BasicImageDataset',
        metainfo=dict(dataset_type='gopro', task_name='deblur'),
        data_root='./data/gopro/train',
        data_prefix=dict(gt='sharp', img='blur'),
        ann_file='meta_info_gopro_train.txt',
        pipeline=[
            dict(type='LoadImageFromFile', key='img'),
            dict(type='LoadImageFromFile', key='gt'),
            dict(type='SetValues', dictionary=dict(scale=1)),
            dict(
                type='Flip',
                keys=['img', 'gt'],
                flip_ratio=0.5,
                direction='horizontal'),
            dict(
                type='Flip',
                keys=['img', 'gt'],
                flip_ratio=0.5,
                direction='vertical'),
            dict(
                type='RandomTransposeHW',
                keys=['img', 'gt'],
                transpose_ratio=0.5),
            dict(type='PairedRandomCrop', gt_patch_size=256),
            dict(type='PackEditInputs')
        ]))
val_dataloader = dict(
    num_workers=4,
    persistent_workers=False,
    drop_last=False,
    sampler=dict(type='DefaultSampler', shuffle=False),
    dataset=dict(
        type='BasicImageDataset',
        metainfo=dict(dataset_type='gopro', task_name='deblur'),
        data_root='./data/gopro/test',
        ann_file='meta_info_gopro_test.txt',
        data_prefix=dict(gt='sharp', img='blur'),
        pipeline=[
            dict(type='LoadImageFromFile', key='img', channel_order='rgb'),
            dict(type='LoadImageFromFile', key='gt', channel_order='rgb'),
            dict(type='PackEditInputs')
        ]))
test_dataloader = dict(
    num_workers=4,
    persistent_workers=False,
    drop_last=False,
    sampler=dict(type='DefaultSampler', shuffle=False),
    dataset=dict(
        type='BasicImageDataset',
        metainfo=dict(dataset_type='gopro', task_name='deblur'),
        data_root='./data/gopro/test',
        ann_file='meta_info_gopro_test.txt',
        data_prefix=dict(gt='sharp', img='blur'),
        pipeline=[
            dict(type='LoadImageFromFile', key='img', channel_order='rgb'),
            dict(type='LoadImageFromFile', key='gt', channel_order='rgb'),
            dict(type='PackEditInputs')
        ]))
val_evaluator = [dict(type='MAE'), dict(type='PSNR'), dict(type='SSIM')]
test_evaluator = [dict(type='MAE'), dict(type='PSNR'), dict(type='SSIM')]
train_cfg = dict(
    type='IterBasedTrainLoop', max_iters=400000, val_interval=20000)
val_cfg = dict(type='EditValLoop')
test_cfg = dict(type='EditTestLoop')
optim_wrapper = dict(
    constructor='DefaultOptimWrapperConstructor',
    type='OptimWrapper',
    optimizer=dict(
        type='AdamW', lr=0.001, weight_decay=0.001, betas=(0.9, 0.9)))
param_scheduler = dict(
    type='CosineAnnealingLR', by_epoch=False, T_max=400000, eta_min=1e-07)
randomness = dict(seed=10, diff_rank_seed=True)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mmdetection-3.x学习笔记——RTMDet模型检测头源码阅读]]></title>
        <id>https://chenjie04.github.io/post/mmdetection-3x-xue-xi-bi-ji-rtmdet-mo-xing-jian-ce-tou-yuan-ma-yue-du/</id>
        <link href="https://chenjie04.github.io/post/mmdetection-3x-xue-xi-bi-ji-rtmdet-mo-xing-jian-ce-tou-yuan-ma-yue-du/">
        </link>
        <updated>2023-03-28T11:13:29.000Z</updated>
        <content type="html"><![CDATA[<p>RTMDet模型的检测头同样基于YOLOX Head，采用分类分支和回归分支解耦的形式，目的就是缓解分类和回归两个任务之间的冲突。不同的是YOLOX 在3个尺度特征图上都共享同一个检测头以降低参数量，但是这也会削弱模型的能力。大多数模型为了提升模型能力都不共享检测头。RTMDet选择了中间策略，不同尺度特征图只共享卷积层，配备独立的BN层、激活层以及最后特征图到预测结果的预测层。当然RTMDet也实现了全共享检测头的RTMDetHead，不过默认采用独立BN层的RTMDetSepBNHead，配置文件如下:</p>
<pre><code class="language-python">bbox_head = dict(
    type=&quot;RTMDetSepBNHead&quot;,
    num_classes=80,
    in_channels=256,
    stacked_convs=2,
    feat_channels=256,
    anchor_generator=dict(type=&quot;MlvlPointGenerator&quot;, offset=0, strides=[8, 16, 32]),
    bbox_coder=dict(type=&quot;DistancePointBBoxCoder&quot;),
    loss_cls=dict(type=&quot;QualityFocalLoss&quot;, use_sigmoid=True, beta=2.0, loss_weight=1.0),
    loss_bbox=dict(type=&quot;GIoULoss&quot;, loss_weight=2.0),
    with_objectness=False,
    exp_on_reg=True,
    share_conv=True,
    pred_kernel_size=1,
    norm_cfg=dict(type=&quot;SyncBN&quot;),
    act_cfg=dict(type=&quot;SiLU&quot;, inplace=True),
)
train_cfg = (
    dict(
        assigner=dict(type=&quot;DynamicSoftLabelAssigner&quot;, topk=13),
        allowed_border=-1,
        pos_weight=-1,
        debug=False,
    ),
)
</code></pre>
<h2 id="rtmdetsepbnhead的网络结构">RTMDetSepBNHead的网络结构</h2>
<p>除却参数共享设置不一致之外，RTMDetSepBNHead和YOLOX Head的结构基本一样，另外，YOLOX Head的Objectness分支在RTMDetSepBNHead被设为了可选选项，而且在目标检测的模型配置文件中都没有启用（with_objectness=False），也就是去掉 Objectness 分支，进一步将 Head 轻量化。。</p>
<figure data-type="image" tabindex="1"><img src="https://chenjie04.github.io/post-images/1680056049237.png" alt="" loading="lazy"></figure>
<p>由上图可知，检测头分分类和回归两个分支，每个分支由2个卷积层加一个预测层，可选的Objectness分支附在回归分支上，检测头网络由def _init_layers(self) -&gt; None构建，具体代码如下：</p>
<pre><code class="language-python">def _init_layers(self) -&gt; None:
    &quot;&quot;&quot;Initialize layers of the head.&quot;&quot;&quot;
    conv = DepthwiseSeparableConvModule if self.use_depthwise else ConvModule
    self.cls_convs = nn.ModuleList() # 分类分支的卷积层
    self.reg_convs = nn.ModuleList() #回归分支的卷积层

    self.rtm_cls = nn.ModuleList() # 分类分支的预测层
    self.rtm_reg = nn.ModuleList() # 回归分支的预测层
    if self.with_objectness: # 如果启用Objectness分支
        self.rtm_obj = nn.ModuleList() # Objectness分支的预测层

    # 遍历strides，也就是遍历不同尺度的特征图，RTMDetSepBNHead选择先为每个尺度的
    # 特征图构建独立的检测头
    for n in range(len(self.prior_generator.strides)): 
        cls_convs = nn.ModuleList()
        reg_convs = nn.ModuleList()
        for i in range(self.stacked_convs): # 遍历卷积层层数并构建
            chn = self.in_channels if i == 0 else self.feat_channels
            cls_convs.append(
                conv(
                    chn,
                    self.feat_channels,
                    3,
                    stride=1,
                    padding=1,
                    conv_cfg=self.conv_cfg,
                    norm_cfg=self.norm_cfg,
                    act_cfg=self.act_cfg,
                )
            )
            reg_convs.append(
                conv(
                    chn,
                    self.feat_channels,
                    3,
                    stride=1,
                    padding=1,
                    conv_cfg=self.conv_cfg,
                    norm_cfg=self.norm_cfg,
                    act_cfg=self.act_cfg,
                )
            )
        self.cls_convs.append(cls_convs)
        self.reg_convs.append(reg_convs)

        self.rtm_cls.append(
            nn.Conv2d(
                self.feat_channels,
                self.num_base_priors * self.cls_out_channels,
                self.pred_kernel_size, # 一般设为1
                padding=self.pred_kernel_size // 2,
            )
        )
        self.rtm_reg.append(
            nn.Conv2d(
                self.feat_channels,
                self.num_base_priors * 4,
                self.pred_kernel_size,
                padding=self.pred_kernel_size // 2,
            )
        )
        if self.with_objectness:
            self.rtm_obj.append(
                nn.Conv2d(
                    self.feat_channels,
                    1,
                    self.pred_kernel_size,
                    padding=self.pred_kernel_size // 2,
                )
            )

</code></pre>
<p>为每个尺度特征图构建检测头之后，采用self.share_conv控制是否共享卷积层，具体代码如下：</p>
<pre><code class="language-python">if self.share_conv:
    for n in range(len(self.prior_generator.strides)): # 遍历特征图的尺度
        for i in range(self.stacked_convs): # 遍历卷积层
            #将第n个尺度对应的检测头中第i卷积模块的卷积层都指向第0个检测头中第i卷积模块的
            #卷积层，从而实现卷积层共享，可以通过id(self.cls_convs[n][i].conv)验证
            self.cls_convs[n][i].conv = self.cls_convs[0][i].conv 
            self.reg_convs[n][i].conv = self.reg_convs[0][i].conv
</code></pre>
<p>RTMDetSepBNHead采用MMCV自定义的ConvModule来构建卷积模块，其为每个网络层定义了名字，卷积层为conv，BN层为bn，激活层为activate，如下所示，因此可以用self.cls_convs[n][i].conv的方式获取该卷积模块的卷积层，</p>
<pre><code class="language-python">(0): ConvModule(
          #params: 0.15M, #flops: 1.24G, #acts: 1.08M
          (conv): Conv2d(
            128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False
            #params: 0.15M, #flops: 1.24G, #acts: 1.08M
          )
          (bn): _BatchNormXd(
            128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True
            #params: 0.26K, #flops: 1.64M, #acts: 0
          )
          (activate): SiLU(inplace=True)
        )
</code></pre>
<h2 id="1-rtmdetsepbnhead的输出">1、RTMDetSepBNHead的输出</h2>
<p>由上面YOLOX Head的图，我们可以知道，YOLOX为每个尺度的特征图生成一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>×</mo><mi>W</mi><mo>×</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">H \times W \times C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>的分类预测图，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>为特征图的高和宽，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>为目标类别总数，当然这里忽略了batch sizes，而且在采用卷积层为预测层的实现中实际输出维度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>×</mo><mi>C</mi><mo>×</mo><mi>H</mi><mo>×</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">B \times C \times H \times W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>。另外，生成的回归分支预测图为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>×</mo><mi>W</mi><mo>×</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">H \times W \times 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>，objectness分支的预测图为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>×</mo><mi>W</mi><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">H \times W \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。回到RTMDetSepBNHead中，其与YOLOX Head的区别在于：</p>
<p>（1）引入self.num_base_priors，可以控制模型为特征图的每个网格点预测多个边界框<br>
（2）在启用objectness分支时，将objectness预测和分类预测合并</p>
<p>所有RTMDetSepBNHead每个尺度的特征图只有两个输出，所有的尺度的输出再组成元组，具体参考下面的注释，需要注意一点就是回归的边界框为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>t</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>x</mi><mo separator="true">,</mo><mi>t</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>y</mi><mo separator="true">,</mo><mi>b</mi><mi>r</mi><mi mathvariant="normal">_</mi><mi>x</mi><mo separator="true">,</mo><mi>b</mi><mi>r</mi><mi mathvariant="normal">_</mi><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[tl\_x, tl\_y, br\_x, br\_y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mopen">[</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span>格式，结合采用的编解码过程（mmdet.DistancePointBBoxCoder）来看，这并不是左上角和右下角坐标，而是中心点到4边的距离(top, bottom, left, right)，需要经过解码过程才得到左上角和右下角坐标。</p>
<pre><code class="language-python">def forward(self, feats: Tuple[Tensor, ...]) -&gt; tuple:
    &quot;&quot;&quot;Forward features from the upstream network.

    Args:
        feats (tuple[Tensor]): Features from the upstream network, each is
            a 4D-tensor.

    Returns:
        tuple: Usually a tuple of classification scores and bbox prediction

        - cls_scores (tuple[Tensor]): Classification scores for all scale
          levels, each is a 4D-tensor, the channels number is
          num_anchors * num_classes. Box scores for each scale level 
          Has shape (N, num_anchors * num_classes, H, W)
        - bbox_preds (tuple[Tensor]): Box energies / deltas for all scale
          levels, each is a 4D-tensor, the channels number is
          num_anchors * 4. Decoded box for each scale level with shape 
          (N, num_anchors * 4, H, W) in [tl_x, tl_y, br_x, br_y] format.
    &quot;&quot;&quot;

    cls_scores = []
    bbox_preds = []
    # 遍历所有尺度特征图
    for idx, (x, stride) in enumerate(zip(feats, self.prior_generator.strides)):
        cls_feat = x
        reg_feat = x

        # 分类分支
        for cls_layer in self.cls_convs[idx]:
            cls_feat = cls_layer(cls_feat)
        cls_score = self.rtm_cls[idx](cls_feat) # 分类预测输出

       # 回归分支
        for reg_layer in self.reg_convs[idx]:
            reg_feat = reg_layer(reg_feat)

       # objectness分支
        if self.with_objectness:
            objectness = self.rtm_obj[idx](reg_feat)
            # 将objectness预测和分类预测合并
            # 这应该是源于TOOD（https://arxiv.org/abs/2108.07755v3） 
            # 将分类分数以及 IOU 相乘计算 Cost 矩阵进行标签匹配
            # sigmoid_geometric_mean(cls_score, objectness) 实现两个sigmoid连续相乘
            # 即 z = (x_sigmoid * y_sigmoid).sqrt()
            # inverse_sigmoid() 即sigmoid的反函数
            cls_score = inverse_sigmoid(sigmoid_geometric_mean(cls_score, objectness))

        if self.exp_on_reg: # bbox的两种解码方式
            reg_dist = self.rtm_reg[idx](reg_feat).exp() * stride[0]
        else:
            reg_dist = self.rtm_reg[idx](reg_feat) * stride[0]

        cls_scores.append(cls_score)
        bbox_preds.append(reg_dist)
    return tuple(cls_scores), tuple(bbox_preds)

</code></pre>
<h2 id="2-获得points先验">2、获得points先验</h2>
<p>获得points先验, 其实就是获取特征图每个点在原图的坐标，RTMDet采用的是MlvlPointGenerator，</p>
<pre><code class="language-python">anchor_generator=dict(type=&quot;MlvlPointGenerator&quot;, offset=0, strides=[8, 16, 32]),
</code></pre>
<p>通过MlvlPointGenerator.grid_priors()获取先验，计算过程很简单，公式为：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mrow><mi>o</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>i</mi><mi>n</mi></mrow></msub><mo separator="true">,</mo><msub><mi>y</mi><mrow><mi>o</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>)</mo><mo>=</mo><mo>(</mo><msub><mi>x</mi><mrow><mi>f</mi><mi>e</mi><mi>a</mi><mi>t</mi></mrow></msub><mo>×</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>d</mi><mi>e</mi><mo separator="true">,</mo><msub><mi>y</mi><mrow><mi>f</mi><mi>e</mi><mi>a</mi><mi>t</mi></mrow></msub><mo>×</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>d</mi><mi>e</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_{origin}, y_{origin}) = (x_{feat} \times stride, y_{feat} \times stride)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span></p>
<p>调用代码：</p>
<pre><code class="language-python">multi_level_anchors = self.prior_generator.grid_priors(
            featmap_sizes, device=device, with_stride=True)
</code></pre>
<p>RTMDet 在3个尺度的特征图上进行检测，那么 multi_level_anchors的维度应该类似于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mo>(</mo><mi>b</mi><mi>s</mi><mo separator="true">,</mo><mi>h</mi><mn>1</mn><mo>∗</mo><mi>w</mi><mn>1</mn><mo separator="true">,</mo><mn>4</mn><mo>)</mo><mo separator="true">,</mo><mo>(</mo><mi>b</mi><mi>s</mi><mo separator="true">,</mo><mi>h</mi><mn>2</mn><mo>∗</mo><mi>w</mi><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo>)</mo><mo separator="true">,</mo><mo>(</mo><mi>b</mi><mi>s</mi><mo separator="true">,</mo><mi>h</mi><mn>3</mn><mo>∗</mo><mi>w</mi><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo>)</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">[(bs, h1*w1, 4), (bs, h2*w2, 4), (bs, h3*w3, 4)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></p>
<p>def grid_priors()函数代码</p>
<pre><code class="language-python">    def grid_priors(self,
                    featmap_sizes: List[Tuple],
                    dtype: torch.dtype = torch.float32,
                    device: DeviceType = 'cuda',
                    with_stride: bool = False) -&gt; List[Tensor]:
        &quot;&quot;&quot;Generate grid points of multiple feature levels.

        Args:
            featmap_sizes (list[tuple]): List of feature map sizes in
                multiple feature levels, each size arrange as
                as (h, w). 例：[(8, 8), (16, 16), (32, 32)]
            dtype (:obj:`dtype`): Dtype of priors. Defaults to torch.float32.
            device (str | torch.device): The device where the anchors will be
                put on.
            with_stride (bool): Whether to concatenate the stride to
                the last dimension of points.

        Return:
            list[torch.Tensor]: Points of  multiple feature levels.
            The sizes of each tensor should be (N, 2) when with stride is
            ``False``, where N = width * height, width and height
            are the sizes of the corresponding feature level,
            and the last dimension 2 represent (coord_x, coord_y),
            otherwise the shape should be (N, 4),
            and the last dimension 4 represent
            (coord_x, coord_y, stride_w, stride_h).
        &quot;&quot;&quot;

        assert self.num_levels == len(featmap_sizes)
        multi_level_priors = []
        for i in range(self.num_levels):
            priors = self.single_level_grid_priors(
                featmap_sizes[i],
                level_idx=i,
                dtype=dtype,
                device=device,
                with_stride=with_stride)
            multi_level_priors.append(priors)
        return multi_level_priors

    def single_level_grid_priors(self,
                                 featmap_size: Tuple[int],
                                 level_idx: int,
                                 dtype: torch.dtype = torch.float32,
                                 device: DeviceType = 'cuda',
                                 with_stride: bool = False) -&gt; Tensor:
        &quot;&quot;&quot;Generate grid Points of a single level.

        Note:
            This function is usually called by method ``self.grid_priors``.

        Args:
            featmap_size (tuple[int]): Size of the feature maps, arrange as
                (h, w).
            level_idx (int): The index of corresponding feature map level.
            dtype (:obj:`dtype`): Dtype of priors. Defaults to torch.float32.
            device (str | torch.device): The device the tensor will be put on.
                Defaults to 'cuda'.
            with_stride (bool): Concatenate the stride to the last dimension
                of points.

        Return:
            Tensor: Points of single feature levels.
            The shape of tensor should be (N, 2) when with stride is
            ``False``, where N = width * height, width and height
            are the sizes of the corresponding feature level,
            and the last dimension 2 represent (coord_x, coord_y),
            otherwise the shape should be (N, 4),
            and the last dimension 4 represent
            (coord_x, coord_y, stride_w, stride_h).
        &quot;&quot;&quot;
        feat_h, feat_w = featmap_size
        stride_w, stride_h = self.strides[level_idx]

        # 生成一个行状为(0, feat_w)的列表，乘以stride，映射回原图
        shift_x = (torch.arange(0, feat_w, device=device) +
                   self.offset) * stride_w
        # keep featmap_size as Tensor instead of int, so that we
        # can convert to ONNX correctly
        shift_x = shift_x.to(dtype)

        shift_y = (torch.arange(0, feat_h, device=device) +
                   self.offset) * stride_h
        # keep featmap_size as Tensor instead of int, so that we
        # can convert to ONNX correctly
        shift_y = shift_y.to(dtype)

        # 获得网格点，就是每个anchor的中心点在原图的坐标
        shift_xx, shift_yy = self._meshgrid(shift_x, shift_y)
        if not with_stride:
            shifts = torch.stack([shift_xx, shift_yy], dim=-1)
        else: # 把strides带上
            # use `shape[0]` instead of `len(shift_xx)` for ONNX export
            stride_w = shift_xx.new_full((shift_xx.shape[0], ),
                                         stride_w).to(dtype)
            stride_h = shift_xx.new_full((shift_yy.shape[0], ),
                                         stride_h).to(dtype)
            shifts = torch.stack([shift_xx, shift_yy, stride_w, stride_h],
                                 dim=-1)
        all_points = shifts.to(device)
        return all_points

    def _meshgrid(self,
                  x: Tensor,
                  y: Tensor,
                  row_major: bool = True) -&gt; Tuple[Tensor, Tensor]:
        yy, xx = torch.meshgrid(y, x)
        if row_major:
            # warning .flatten() would cause error in ONNX exporting
            # have to use reshape here
            return xx.reshape(-1), yy.reshape(-1)

        else:
            return yy.reshape(-1), xx.reshape(-1)  
</code></pre>
<h3 id="valid_flags">valid_flags</h3>
<p>（个人理解，还不确定是否准确）由于在pytorch的dataloader组装batch时，也就是调用collate_fn 函数时，填充了大量黑边，所以在黑边上的point不用计算loss，可以忽略，节省算力。因此valid_flags返回有效的point索引。</p>
<p>我认为这一步只能忽略组batch时添加的padding，而在数据增广流程中调用的Pad类添加的padding是无法去掉的。所以在RTMDet中由于在数据增广流程中调用Pad类将每张图片padding成(640, 640)大小，那么组batch时就不用padding了，那么这里的每个points先验都是有效的。</p>
<p>collate_fn (Callable, optional) – merges a list of samples to form a mini-batch of Tensor(s). Used when using batched loading from a map-style dataset.</p>
<pre><code class="language-python">    def valid_flags(self,
                    featmap_sizes: List[Tuple[int, int]],
                    pad_shape: Tuple[int],
                    device: DeviceType = 'cuda') -&gt; List[Tensor]:

        # pad_shape是有效的特征图大小，是指Pad后的size，collate_fn之前

        &quot;&quot;&quot;Generate valid flags of points of multiple feature levels.

        Args:
            featmap_sizes (list(tuple)): List of feature map sizes in
                multiple feature levels, each size arrange as
                as (h, w).
            pad_shape (tuple(int)): The padded shape of the image,
                arrange as (h, w).
            device (str | torch.device): The device where the anchors will be
                put on.

        Return:
            list(torch.Tensor): Valid flags of points of multiple levels.
        &quot;&quot;&quot;
        assert self.num_levels == len(featmap_sizes)
        multi_level_flags = []
        for i in range(self.num_levels):
            point_stride = self.strides[i]
            feat_h, feat_w = featmap_sizes[i]
            h, w = pad_shape[:2]
            # 获得有效的特征图的高和宽
            valid_feat_h = min(int(np.ceil(h / point_stride[1])), feat_h)
            valid_feat_w = min(int(np.ceil(w / point_stride[0])), feat_w)
            flags = self.single_level_valid_flags((feat_h, feat_w),
                                                  (valid_feat_h, valid_feat_w),
                                                  device=device)
            multi_level_flags.append(flags)
        return multi_level_flags

    def single_level_valid_flags(self,
                                 featmap_size: Tuple[int, int],
                                 valid_size: Tuple[int, int],
                                 device: DeviceType = 'cuda') -&gt; Tensor:
        &quot;&quot;&quot;Generate the valid flags of points of a single feature map.

        Args:
            featmap_size (tuple[int]): The size of feature maps, arrange as
                as (h, w).
            valid_size (tuple[int]): The valid size of the feature maps.
                The size arrange as as (h, w).
            device (str | torch.device): The device where the flags will be
            put on. Defaults to 'cuda'.

        Returns:
            torch.Tensor: The valid flags of each points in a single level \
                feature map.
        &quot;&quot;&quot;
        feat_h, feat_w = featmap_size
        valid_h, valid_w = valid_size
        assert valid_h &lt;= feat_h and valid_w &lt;= feat_w
        # 有效位置设置为1，否则为0
        valid_x = torch.zeros(feat_w, dtype=torch.bool, device=device)
        valid_y = torch.zeros(feat_h, dtype=torch.bool, device=device)
        valid_x[:valid_w] = 1
        valid_y[:valid_h] = 1
        valid_xx, valid_yy = self._meshgrid(valid_x, valid_y)
        valid = valid_xx &amp; valid_yy
        return valid
</code></pre>
<h2 id="3-将分类分支的预测结果展成以为并将同一张图片的预测结果串联起来">3、将分类分支的预测结果展成以为并将同一张图片的预测结果串联起来</h2>
<pre><code class="language-python">flatten_cls_scores = torch.cat([
            cls_score.permute(0, 2, 3, 1).reshape(num_imgs, -1,
                                                  self.cls_out_channels)
            for cls_score in cls_scores
        ], 1)
</code></pre>
<p>此时flatten_cls_scores的维度应该是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>n</mi><mi>u</mi><msub><mi>m</mi><mi>i</mi></msub><mi>m</mi><mi>g</mi><mi>s</mi><mo separator="true">,</mo><mi>n</mi><mi>u</mi><msub><mi>m</mi><mi>p</mi></msub><mi>r</mi><mi>i</mi><mi>o</mi><mi>r</mi><mi>s</mi><mo separator="true">,</mo><mi>n</mi><mi>u</mi><msub><mi>m</mi><mi>c</mi></msub><mi>l</mi><mi>a</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>s</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[num_imgs, num_priors, num_classes]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mclose">]</span></span></span></span>，num_imgs就是batch_size，num_priors应该等于3张特征图维度相加，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>h</mi><mn>1</mn><mo>∗</mo><mi>w</mi><mn>1</mn><mo>+</mo><mi>h</mi><mn>2</mn><mo>∗</mo><mi>w</mi><mn>2</mn><mo>+</mo><mi>h</mi><mn>3</mn><mo>∗</mo><mi>w</mi><mn>3</mn><mo>)</mo><mo>∗</mo><mi>s</mi><mi>e</mi><mi>l</mi><mi>f</mi><mi mathvariant="normal">.</mi><mi>n</mi><mi>u</mi><msub><mi>m</mi><mi>b</mi></msub><mi>a</mi><mi>s</mi><msub><mi>e</mi><mi>p</mi></msub><mi>r</mi><mi>i</mi><mi>o</mi><mi>r</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">(h1*w1 + h2*w2 + h3*w3) * self.num_base_priors</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord">.</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span></span></span></span></p>
<h2 id="4-将回归分支预测的中心点到四边的距离解码成bbox并将同一张图片的预测结果串联起来">4、将回归分支预测的中心点到四边的距离解码成bbox并将同一张图片的预测结果串联起来</h2>
<pre><code class="language-python">decoded_bboxes = []
        for anchor, bbox_pred in zip(anchor_list[0], bbox_preds):
            anchor = anchor.reshape(-1, 4)
            bbox_pred = bbox_pred.permute(0, 2, 3, 1).reshape(num_imgs, -1, 4)
            bbox_pred = distance2bbox(anchor, bbox_pred)
            decoded_bboxes.append(bbox_pred)

        flatten_bboxes = torch.cat(decoded_bboxes, 1)
</code></pre>
<p>RTNDet采用的编解码器为DistancePointBBoxCoder，</p>
<pre><code class="language-python">bbox_coder=dict(type=&quot;DistancePointBBoxCoder&quot;)
</code></pre>
<p>首先来看一下从预测距离转化成真实的边界框的左上坐标和右下坐标的解码过程。</p>
<pre><code class="language-python">def distance2bbox(
    points: Tensor,
    distance: Tensor,
    ....
) -&gt; Tensor:
    &quot;&quot;&quot;Decode distance prediction to bounding box.

    Args:
        points (Tensor): Shape (B, N, 2) or (N, 2). 网格中心点坐标
        distance (Tensor): Distance from the given point to 4
            boundaries (left, top, right, bottom). Shape (B, N, 4) or (N, 4) 
            预测的中心点到边界框四边的距离

    Returns:
        Tensor: Boxes with shape (N, 4) or (B, N, 4)
    &quot;&quot;&quot;

    x1 = points[..., 0] - distance[..., 0] # 中心点x坐标 - 左边距离 = 边界框左上角x坐标
    y1 = points[..., 1] - distance[..., 1] # 中心点y坐标 - 上边距离 = 边界框左上角y坐标
    x2 = points[..., 0] + distance[..., 2] # 中心点x坐标 - 右边距离 = 边界框右下角x坐标
    y2 = points[..., 1] + distance[..., 3]   # 中心点y坐标 - 下边距离 = 边界框右下角y坐标

    bboxes = torch.stack([x1, y1, x2, y2], -1)
    ......

    return bboxes

</code></pre>
<p>将 gt bboxes (x1, y1, x2, y2) 编码为 (top, bottom, left, right)的编码过程，</p>
<pre><code class="language-python">def bbox2distance(points: Tensor,
                  bbox: Tensor,
                  .......) -&gt; Tensor:
    &quot;&quot;&quot;Decode bounding box based on distances.

    Args:
        points (Tensor): Shape (n, 2) or (b, n, 2), [x, y].  网格中心点坐标
        bbox (Tensor): Shape (n, 4) or (b, n, 4), &quot;xyxy&quot; format 真实值Ground Truth的左上角和右下角坐标
        ......

    Returns:
        Tensor: Decoded distances.
    &quot;&quot;&quot;
    left = points[..., 0] - bbox[..., 0] # 中心点x坐标 - 边界框左上角x坐标 = 左边距离
    top = points[..., 1] - bbox[..., 1]  # 中心点y坐标 - 边界框左上角y坐标 =  上边距离
    right = bbox[..., 2] - points[..., 0] # 边界框右下角x坐标 - 中心点x坐标 = 右边距离
    bottom = bbox[..., 3] - points[..., 1] # 边界框右下角y坐标 - 中心点y坐标 = 右边距离
    .....
    return torch.stack([left, top, right, bottom], -1)
</code></pre>
<h2 id="5-将展开后的预测结果-pointsanchors先验-ground-truth等传入selfget_targets准备进行正负样本分配">5、将展开后的预测结果、points（anchors）先验、Ground Truth等传入self.get_targets()准备进行正负样本分配</h2>
<pre><code class="language-python">cls_reg_targets = self.get_targets(
            flatten_cls_scores,
            flatten_bboxes,
            anchor_list,
            valid_flag_list,
            batch_gt_instances,
            batch_img_metas,
            batch_gt_instances_ignore=batch_gt_instances_ignore)
</code></pre>
<p>注意这里是整个batch的数据传入self.get_targets()函数的，而且anchors_list的维度还是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mo>(</mo><mi>b</mi><mi>s</mi><mo separator="true">,</mo><mi>h</mi><mn>1</mn><mo>∗</mo><mi>w</mi><mn>1</mn><mo separator="true">,</mo><mn>4</mn><mo>)</mo><mo separator="true">,</mo><mo>(</mo><mi>b</mi><mi>s</mi><mo separator="true">,</mo><mi>h</mi><mn>2</mn><mo>∗</mo><mi>w</mi><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo>)</mo><mo separator="true">,</mo><mo>(</mo><mi>b</mi><mi>s</mi><mo separator="true">,</mo><mi>h</mi><mn>3</mn><mo>∗</mo><mi>w</mi><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo>)</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">[(bs, h1*w1, 4), (bs, h2*w2, 4), (bs, h3*w3, 4)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span>，所以得进行一维展开，</p>
<pre><code class="language-python">    def get_targets(self,
                    cls_scores: Tensor,
                    bbox_preds: Tensor,
                    anchor_list: List[List[Tensor]],
                    valid_flag_list: List[List[Tensor]],
                    batch_gt_instances: InstanceList,
                    batch_img_metas: List[dict],
                    batch_gt_instances_ignore: OptInstanceList = None,
                    unmap_outputs=True):

        num_imgs = len(batch_img_metas)
        assert len(anchor_list) == len(valid_flag_list) == num_imgs

        # anchor number of multi levels
        num_level_anchors = [anchors.size(0) for anchors in anchor_list[0]]

        # concat all level anchors and flags to a single tensor
        for i in range(num_imgs):
            assert len(anchor_list[i]) == len(valid_flag_list[i])
            anchor_list[i] = torch.cat(anchor_list[i])
            valid_flag_list[i] = torch.cat(valid_flag_list[i])

    ........
</code></pre>
<p>对gt_ignore 处理一下</p>
<pre><code class="language-python"># compute targets for each image
        if batch_gt_instances_ignore is None:
            batch_gt_instances_ignore = [None] * num_imgs
</code></pre>
<p>关于目标检测中gt_ignore的简单理解：目标过小，过于模糊当做ignore属性处理，训练时，给样本-1类别（背景为0类别）。评测时候需要考虑ignore样本，输出不算错。在有的模型的正负样本分配过程中，ignore区域使用是在一张图片挑选完正样本的时候，剩下的负样本按理来说是正常的从中random抽取，但是对于和ignore区域交叉大于0.5的区域是不能作为负样本的，因为这些区域不是没有人的区域，所以说ignore区域是人，但是这个人的遮挡太多了，所以要ignore，所以对于图片上的人啊，led里面的人是不能作为ignore区域的，因为要抑制掉！！！</p>
<p>在self.get_targets()函数内部调用self._get_targets_single进行单张图片的正负样本分配</p>
<pre><code class="language-python">       (all_anchors, all_labels, all_label_weights, all_bbox_targets,
         all_assign_metrics, sampling_results_list) = multi_apply(
             self._get_targets_single,
             cls_scores.detach(),
             bbox_preds.detach(),
             anchor_list,
             valid_flag_list,
             batch_gt_instances,
             batch_img_metas,
             batch_gt_instances_ignore,
             unmap_outputs=unmap_outputs)
</code></pre>
<h2 id="6-在self_get_targets_single函数内部去掉超出图片范围的anchors对模型的预测结果和anchors一起用抽象数据接口instancedata封装然后送入样本分配器进行正负样本的分配">6、在self._get_targets_single()函数内部，去掉超出图片范围的anchors，对模型的预测结果和anchors一起用抽象数据接口InstanceData封装，然后送入样本分配器进行正负样本的分配</h2>
<p>这里应该是要处理数据增广流程中Pad流程中引入的padding了，这些padding区域的anchors也是无效的。</p>
<pre><code class="language-python">        inside_flags = anchor_inside_flags(flat_anchors, valid_flags,
                                           img_meta['img_shape'][:2],  # 这里获取图像的真实范围
                                           self.train_cfg['allowed_border']) # 是否允许超出一定边界
        if not inside_flags.any():
            return (None, ) * 7
        # assign gt and sample anchors
        anchors = flat_anchors[inside_flags, :]
</code></pre>
<pre><code class="language-python">def anchor_inside_flags(flat_anchors: Tensor,
                        valid_flags: Tensor,
                        img_shape: Tuple[int],
                        allowed_border: int = 0) -&gt; Tensor:

    img_h, img_w = img_shape[:2]
    if allowed_border &gt;= 0:
        if isinstance(flat_anchors, BaseBoxes):
            inside_flags = valid_flags &amp; \
                flat_anchors.is_inside([img_h, img_w], 
                                       all_inside=True,
                                       allowed_border=allowed_border)
        # flat_anchors.is_inside()是BaseBoxes类中找出在图像范围内anchors的方法
        else:
            inside_flags = valid_flags &amp; \
                (flat_anchors[:, 0] &gt;= -allowed_border) &amp; \
                (flat_anchors[:, 1] &gt;= -allowed_border) &amp; \
                (flat_anchors[:, 2] &lt; img_w + allowed_border) &amp; \
                (flat_anchors[:, 3] &lt; img_h + allowed_border)
    else:
        inside_flags = valid_flags
    return inside_flags
</code></pre>
<p>去除无效anchors后，对模型的预测结果和anchors一起用抽象数据接口InstanceData封装，然后送入样本分配器进行正负样本的分配。</p>
<pre><code class="language-python">        pred_instances = InstanceData(
            scores=cls_scores[inside_flags, :],
            bboxes=bbox_preds[inside_flags, :],
            priors=anchors)

        assign_result = self.assigner.assign(pred_instances, gt_instances,
                                             gt_instances_ignore)
</code></pre>
<p>关于抽象数据接口</p>
<p>MMEngine定义了数据基类BaseDataElement， 中存在两种类型的数据，一种是 data 类型，如标注框、框的标签、和实例掩码等；另一种是 metainfo 类型，包含数据的元信息以确保数据的完整性，如 img_shape, img_id 等数据所在图片的一些基本信息，方便可视化等情况下对数据进行恢复和使用。</p>
<p>InstanceData 在 BaseDataElement 的基础上，对 data 存储的数据做了限制，即要求存储在 data 中的数据的长度一致。比如在目标检测中, 假设一张图像中有 N 个目标(instance)，可以将图像的所有边界框(bbox)，类别(label)等存储在 InstanceData 中, InstanceData 的 bbox 和 label 的长度相同。 基于上述假定对 InstanceData进行了扩展，包括：</p>
<ul>
<li>
<p>对 InstanceData 中 data 所存储的数据进行了长度校验</p>
</li>
<li>
<p>data 部分支持类字典访问和设置它的属性</p>
</li>
<li>
<p>支持基础索引，切片以及高级索引功能</p>
</li>
<li>
<p>支持具有相同的 key 但是不同 InstanceData 的拼接功能。 这些扩展功能除了支持基础的数据结构， 比如torch.tensor, numpy.dnarray, list, str, tuple, 也可以是自定义的数据结构，只要自定义数据结构实现了 __len__, __getitem__ and cat.</p>
</li>
</ul>
<p>详情查阅<a href="https://mmengine.readthedocs.io/zh_CN/latest/advanced_tutorials/data_element.html#">MMEngine抽象数据接口文档</a>，示例如下：</p>
<pre><code class="language-python">&lt;InstanceData(

    META INFORMATION
    pad_shape: (800, 1216, 3)
    img_shape: (800, 1196, 3)

    DATA FIELDS
    cls_scores: tensor([0.8000, 0.7000])
    bbox_preds: tensor([[0.6576, 0.5435, 0.5253, 0.8273],
                [0.4533, 0.6848, 0.7230, 0.9279]])
    anchors: tensor([[0.6566, 0.1254, 0.5253, 0.8273],
                [0.4533, 0.6848, 0.7230, 0.9279]])
) at 0x7f9f339f8ca0&gt;
</code></pre>
<h2 id="7-dynamicsoftlabelassigner正负样本分配">7、DynamicSoftLabelAssigner正负样本分配</h2>
<p>RTMDet基于YOLOX的SimOTA进行了改进，提出了DynamicSoftLabelAssigner, 正负样本的分配主要由该类完成。</p>
<pre><code class="language-python">assigner=dict(type=&quot;DynamicSoftLabelAssigner&quot;, topk=13)
</code></pre>
<pre><code class="language-python">@TASK_UTILS.register_module()
class DynamicSoftLabelAssigner(BaseAssigner):
    &quot;&quot;&quot;Computes matching between predictions and ground truth with dynamic soft
    label assignment.

    Args:
        soft_center_radius (float): Radius of the soft center prior.
            Defaults to 3.0.
        topk (int): Select top-k predictions to calculate dynamic k
            best matches for each gt. Defaults to 13.
        iou_weight (float): The scale factor of iou cost. Defaults to 3.0.
        iou_calculator (ConfigType): Config of overlaps Calculator.
            Defaults to dict(type='BboxOverlaps2D').
    &quot;&quot;&quot;

    def __init__(
        self,
        soft_center_radius: float = 3.0,
        topk: int = 13,
        iou_weight: float = 3.0,
        iou_calculator: ConfigType = dict(type='BboxOverlaps2D')
    ) -&gt; None:
        self.soft_center_radius = soft_center_radius
        self.topk = topk
        self.iou_weight = iou_weight
        self.iou_calculator = TASK_UTILS.build(iou_calculator)

    def assign(self,
               pred_instances: InstanceData,
               gt_instances: InstanceData,
               gt_instances_ignore: Optional[InstanceData] = None,
               **kwargs) -&gt; AssignResult:
        &quot;&quot;&quot;Assign gt to priors.

        Args:
            pred_instances (:obj:`InstanceData`): Instances of model
                predictions. It includes ``priors``, and the priors can
                be anchors or points, or the bboxes predicted by the
                previous stage, has shape (n, 4). The bboxes predicted by
                the current model or stage will be named ``bboxes``,
                ``labels``, and ``scores``, the same as the ``InstanceData``
                in other places.
            gt_instances (:obj:`InstanceData`): Ground truth of instance
                annotations. It usually includes ``bboxes``, with shape (k, 4),
                and ``labels``, with shape (k, ).
            gt_instances_ignore (:obj:`InstanceData`, optional): Instances
                to be ignored during training. It includes ``bboxes``
                attribute data that is ignored during training and testing.
                Defaults to None.
        Returns:
            obj:`AssignResult`: The assigned result.
        &quot;&quot;&quot;
        gt_bboxes = gt_instances.bboxes
        gt_labels = gt_instances.labels
        num_gt = gt_bboxes.size(0)

        decoded_bboxes = pred_instances.bboxes
        pred_scores = pred_instances.scores
        priors = pred_instances.priors
        num_bboxes = decoded_bboxes.size(0)

        # assign 0 by default
        # 每个预测的bbox只允许匹配一个Ground Truth
        assigned_gt_inds = decoded_bboxes.new_full((num_bboxes, ),
                                                   0,
                                                   dtype=torch.long)
        
        # 加入没有Ground Truth或者预测结果为空，则返回空的分配结果
        if num_gt == 0 or num_bboxes == 0:
            # No ground truth or boxes, return empty assignment
            max_overlaps = decoded_bboxes.new_zeros((num_bboxes, ))
            if num_gt == 0:
                # No truth, assign everything to background
                assigned_gt_inds[:] = 0
            assigned_labels = decoded_bboxes.new_full((num_bboxes, ),
                                                      -1,
                                                      dtype=torch.long)
            return AssignResult(
                num_gt, assigned_gt_inds, max_overlaps, labels=assigned_labels)

        # 找出中心点在Ground Truth内的priors
        prior_center = priors[:, :2] # (n, 2)
        if isinstance(gt_bboxes, BaseBoxes):
            is_in_gts = gt_bboxes.find_inside_points(prior_center)
        else:
            # Tensor boxes will be treated as horizontal boxes by defaults
            # prior_center[:, None].shape: (num_priors, 1, 2)
            # gt_bboxes[:, :2].shape: (num_gt,2)
            # 两者通过广播机制实现相减
            lt_ = prior_center[:, None] - gt_bboxes[:, :2] # 中心点到每个真值框左边和上边的距离，维度为(num_priors, num_gt, 2)
            rb_ = gt_bboxes[:, 2:] - prior_center[:, None] # 中心点到每个真值框右边和下边的距离，维度为(num_priors, num_gt, 2)

            deltas = torch.cat([lt_, rb_], dim=-1)
            is_in_gts = deltas.min(dim=-1).values &gt; 0 # 中心点到每个真值框四边的距离，维度为(num_priors, num_gt, 4)，只有四边距离的最小值都大于0，才能说该prior在该真值框内，最后得到的is_in_gts的维度为(num_priors,num_gt)

        valid_mask = is_in_gts.sum(dim=1) &gt; 0 # 可能存在真值框重叠的情况，即一个prior在多个真值框内，所以对is_in_gts的第一个维度求和大于0的中心点在Ground Truth内的priors

        # 取得中心点在Ground Truth内的有效预测结果
        valid_decoded_bbox = decoded_bboxes[valid_mask]
        valid_pred_scores = pred_scores[valid_mask]
        num_valid = valid_decoded_bbox.size(0)

        # 如果所有预测结果的中心点都不在Ground Truth内（是指没有Ground Truth或预测的bboxes）返回空的分配结果
        if num_valid == 0:
            # No ground truth or boxes, return empty assignment
            max_overlaps = decoded_bboxes.new_zeros((num_bboxes, ))
            assigned_labels = decoded_bboxes.new_full((num_bboxes, ),
                                                      -1,
                                                      dtype=torch.long)
            return AssignResult(
                num_gt, assigned_gt_inds, max_overlaps, labels=assigned_labels)
        
        if hasattr(gt_instances, 'masks'):
            gt_center = center_of_mass(gt_instances.masks, eps=EPS) # 实例分割的？
        elif isinstance(gt_bboxes, BaseBoxes):
            gt_center = gt_bboxes.centers
        else:
            # Tensor boxes will be treated as horizontal boxes by defaults
            gt_center = (gt_bboxes[:, :2] + gt_bboxes[:, 2:]) / 2.0 # （左上角坐标 + 右下角坐标）/ 2 = 中心点坐标

        valid_prior = priors[valid_mask] # 过滤无效的先验，假设有效先验的数量为num_val，则valid_prior维度为(num_val,4)
        strides = valid_prior[:, 2] # 进而获取有效先验对应的strides, 维度为(num_val,1)
        distance = (valid_prior[:, None, :2] - gt_center[None, :, :]
                    ).pow(2).sum(-1).sqrt() / strides[:, None] # 有效先验中心点到Ground Truth中心点的距离，维度应该是(num_val, num_gt)
        soft_center_prior = torch.pow(10, distance - self.soft_center_radius)

        pairwise_ious = self.iou_calculator(valid_decoded_bbox, gt_bboxes) # 维度应该是(num_val, num_gt)
        iou_cost = -torch.log(pairwise_ious + EPS) * self.iou_weight # (num_val, num_gt)

        # pred_scores.shape[-1]是目标类别总数
        # F.one_hot(gt_labels.to(torch.int64), pred_scores.shape[-1])得到的维度应该是(num_gt, num_class)
        gt_onehot_label = (
            F.one_hot(gt_labels.to(torch.int64),
                      pred_scores.shape[-1]).float().unsqueeze(0).repeat(
                          num_valid, 1, 1)) # 重复num_val次是因为每个prior需要和每个Ground Truth计算损失，此时维度为(num_val, num_gt, num_class)
        valid_pred_scores = valid_pred_scores.unsqueeze(1).repeat(1, num_gt, 1) # 维度为(num_val, num_gt, num_class)

        soft_label = gt_onehot_label * pairwise_ious[..., None] # 预测结果和真实值之间的IoU作为软标签$Y_{soft}$

        scale_factor = soft_label - valid_pred_scores.sigmoid()  # 维度为(num_val, num_gt, num_class) 对应分类代价函数的$(Y_{soft} - P)$
        soft_cls_cost = F.binary_cross_entropy_with_logits(
            valid_pred_scores, soft_label,
            reduction='none') * scale_factor.abs().pow(2.0) # reduction='none'表示计算交叉熵后不计算平均值，而是保持维度不变
        soft_cls_cost = soft_cls_cost.sum(dim=-1) # (num_val, num_gt)

        cost_matrix = soft_cls_cost + iou_cost + soft_center_prior # (num_val, num_gt) 代价矩阵，每一行代表该预测结果相对于每个gt的分配代价

        matched_pred_ious, matched_gt_inds = self.dynamic_k_matching(
            cost_matrix, pairwise_ious, num_gt, valid_mask)

        # convert to AssignResult format
        assigned_gt_inds[valid_mask] = matched_gt_inds + 1
        assigned_labels = assigned_gt_inds.new_full((num_bboxes, ), -1)
        assigned_labels[valid_mask] = gt_labels[matched_gt_inds].long()
        max_overlaps = assigned_gt_inds.new_full((num_bboxes, ),
                                                 -INF,
                                                 dtype=torch.float32)
        max_overlaps[valid_mask] = matched_pred_ious
        return AssignResult(
            num_gt, assigned_gt_inds, max_overlaps, labels=assigned_labels)

    def dynamic_k_matching(self, cost: Tensor, pairwise_ious: Tensor,
                           num_gt: int,
                           valid_mask: Tensor) -&gt; Tuple[Tensor, Tensor]:
        &quot;&quot;&quot;Use IoU and matching cost to calculate the dynamic top-k positive
        targets. Same as SimOTA.

        Args:
            cost (Tensor): Cost matrix. (num_val, num_gt)
            pairwise_ious (Tensor): Pairwise iou matrix. (num_val, num_gt)
            num_gt (int): Number of gt. 
            valid_mask (Tensor): Mask for valid bboxes. (num_priors,) 其中有限先验为True，无效先验为False

        Returns:
            tuple: matched ious and gt indexes.
        &quot;&quot;&quot;
        # 匹配矩阵初始化为 0 
        matching_matrix = torch.zeros_like(cost, dtype=torch.uint8)

        # select candidate topk ious for dynamic-k calculation
        # self.topk = 13, pairwise_ious.size(0) = num_val
        candidate_topk = min(self.topk, pairwise_ious.size(0))
        topk_ious, _ = torch.topk(pairwise_ious, candidate_topk, dim=0) # 沿着维度0选取topk，即为每个gt选取前topk个iou最大的bbox, 维度为(topk, num_gt)
        # calculate dynamic k for each gt
        # 计算每一个 gt 与所有 bboxes 前 13 大的 iou的和取整后作为这个 gt 的 样本数目 , 最少为 1 个, 记为 dynamic_ks, 维度为(num_gt,)
        dynamic_ks = torch.clamp(topk_ious.sum(0).int(), min=1)

        # 对于每一个 gt , 将其 cost_matrix 矩阵前 `dynamic_ks 小的位置作为该 gt 的正样本
        for gt_idx in range(num_gt):
            _, pos_idx = torch.topk(
                cost[:, gt_idx], k=dynamic_ks[gt_idx], largest=False)
            matching_matrix[:, gt_idx][pos_idx] = 1

        del topk_ious, dynamic_ks, pos_idx # 删除中间变量

        # 对于某一个 bbox, 如果被匹配到多个 gt 就将与这些 gts 的 cost_marix 中最小的那个作为其 label
        prior_match_gt_mask = matching_matrix.sum(1) &gt; 1 # 先验匹配gt掩码，判断维度1上的和是否大于1，找出匹配上多个gt的预测点
        if prior_match_gt_mask.sum() &gt; 0:
            cost_min, cost_argmin = torch.min(
                cost[prior_match_gt_mask, :], dim=1)
            matching_matrix[prior_match_gt_mask, :] *= 0
            matching_matrix[prior_match_gt_mask, cost_argmin] = 1

        # get foreground mask inside box and center prior
        fg_mask_inboxes = matching_matrix.sum(1) &gt; 0 # 前景掩码
        # 更新前景掩码，在前面中心先验的前提下进一步筛选正样本 
        # 注意这个索引方式,valid_mask是一个bool类型tensor,以自己为索引会返回所有为True的位置
        # 也就是说 valid_mask的维度本来是(num_priors,),以自己为索引会返回所有为True的位置后维度自然就变成了(num_val,)
        valid_mask[valid_mask.clone()] = fg_mask_inboxes

        # 该候选框匹配到哪个 gt bbox
        matched_gt_inds = matching_matrix[fg_mask_inboxes, :].argmax(1)

        # 提取对应的预测点和gt bbox 的 iou 
        matched_pred_ious = (matching_matrix *
                             pairwise_ious).sum(1)[fg_mask_inboxes]
        
        return matched_pred_ious, matched_gt_inds

</code></pre>
<p>样本分配结果采用AssignResult类封装</p>
<pre><code class="language-python">class AssignResult(util_mixins.NiceRepr):
    def __init__(self, num_gts: int, gt_inds: Tensor, max_overlaps: Tensor,
                 labels: Tensor) -&gt; None:
        self.num_gts = num_gts
        self.gt_inds = gt_inds
        self.max_overlaps = max_overlaps
        self.labels = labels
        # Interface for possible user-defined properties
        self._extra_properties = {}
</code></pre>
<h2 id="8-正负样本采样">8、正负样本采样</h2>
<p>在目标检测流程中，一眼分配完正负样本之后还会进行一个采样的过程，目的是为了让正负样本更加均衡。RTMDet采用的是伪采样器，即实际上不进行采样，直接返回正负样本的索引</p>
<pre><code class="language-python">class PseudoSampler(BaseSampler):
    &quot;&quot;&quot;A pseudo sampler that does not do sampling actually.&quot;&quot;&quot;

    def __init__(self, **kwargs):
        pass

    def _sample_pos(self, **kwargs):
        &quot;&quot;&quot;Sample positive samples.&quot;&quot;&quot;
        raise NotImplementedError

    def _sample_neg(self, **kwargs):
        &quot;&quot;&quot;Sample negative samples.&quot;&quot;&quot;
        raise NotImplementedError

    def sample(self, assign_result: AssignResult, pred_instances: InstanceData,
               gt_instances: InstanceData, *args, **kwargs):
        &quot;&quot;&quot;Directly returns the positive and negative indices  of samples.

        Args:
            assign_result (:obj:`AssignResult`): Bbox assigning results.
            pred_instances (:obj:`InstanceData`): Instances of model
                predictions. It includes ``priors``, and the priors can
                be anchors, points, or bboxes predicted by the model,
                shape(n, 4).
            gt_instances (:obj:`InstanceData`): Ground truth of instance
                annotations. It usually includes ``bboxes`` and ``labels``
                attributes.

        Returns:
            :obj:`SamplingResult`: sampler results
        &quot;&quot;&quot;
        gt_bboxes = gt_instances.bboxes
        priors = pred_instances.priors
        
        # torch.nonezero()的作用就是找到tensor中所有不为0的索引。
        pos_inds = torch.nonzero( # 正样本索引
            assign_result.gt_inds &gt; 0, as_tuple=False).squeeze(-1).unique()
        neg_inds = torch.nonzero( # 负样本索引
            assign_result.gt_inds == 0, as_tuple=False).squeeze(-1).unique()

        gt_flags = priors.new_zeros(priors.shape[0], dtype=torch.uint8) # 这是干啥的？
        sampling_result = SamplingResult(
            pos_inds=pos_inds,
            neg_inds=neg_inds,
            priors=priors,
            gt_bboxes=gt_bboxes,
            assign_result=assign_result,
            gt_flags=gt_flags,
            avg_factor_with_neg=False)
        return sampling_result
</code></pre>
<p>抽样结果采用SamplingResult封装，比较重要是下面添加注释的那几项，预测结果中哪些是正样本、哪些是负样本，每个正样本负责预测哪个ground truth，对应的类别是什么</p>
<pre><code class="language-python">class SamplingResult(util_mixins.NiceRepr):
    def __init__(self,
                 pos_inds: Tensor,
                 neg_inds: Tensor,
                 priors: Tensor,
                 gt_bboxes: Tensor,
                 assign_result: AssignResult,
                 gt_flags: Tensor,
                 avg_factor_with_neg: bool = True) -&gt; None:
        self.pos_inds = pos_inds
        self.neg_inds = neg_inds
        self.num_pos = max(pos_inds.numel(), 1)
        self.num_neg = max(neg_inds.numel(), 1)
        self.avg_factor_with_neg = avg_factor_with_neg
        self.avg_factor = self.num_pos + self.num_neg \
            if avg_factor_with_neg else self.num_pos
        self.pos_priors = priors[pos_inds] # 正样本
        self.neg_priors = priors[neg_inds] # 负样本
        self.pos_is_gt = gt_flags[pos_inds]

        self.num_gts = gt_bboxes.shape[0]
        self.pos_assigned_gt_inds = assign_result.gt_inds[pos_inds] - 1 # 正样本负责预测ground truth的索引
        self.pos_gt_labels = assign_result.labels[pos_inds] # 该正样本应该是哪个类别
        box_dim = gt_bboxes.box_dim if isinstance(gt_bboxes, BaseBoxes) else 4
        if gt_bboxes.numel() == 0:
            # hack for index error case
            assert self.pos_assigned_gt_inds.numel() == 0
            self.pos_gt_bboxes = gt_bboxes.view(-1, box_dim)
        else:
            if len(gt_bboxes.shape) &lt; 2:
                gt_bboxes = gt_bboxes.view(-1, box_dim)
            self.pos_gt_bboxes = gt_bboxes[self.pos_assigned_gt_inds.long()] # 正样本负责预测ground truth的bbox

</code></pre>
<h2 id="9-根据抽样结果构建用于计算loss的target">9、根据抽样结果构建用于计算loss的target</h2>
<p>回顾一下，我们送入正负样本分配器和抽样器的是在真实图片范围内的anchors，</p>
<pre><code class="language-python">anchors = flat_anchors[inside_flags, :] 
</code></pre>
<p>因此需要先构建anchors对应的target，包括bbox_terget(每个anchor对应的目标bbox，正样本对应真实的bbox，负样本对应0)、目标标签labels（同样正样本对应真值的标签，负样本对应0）、标签类别的权重、用于计算QualityFocalLoss的assign_metrics，构建过程如下：</p>
<pre><code class="language-python">num_valid_anchors = anchors.shape[0] # 
        bbox_targets = torch.zeros_like(anchors) # 初始化每个有效anchor对应的边界框目标为0
        labels = anchors.new_full((num_valid_anchors, ), # 初始化每个有效anchor对应的标签目标为目标类别数
                                  self.num_classes,
                                  dtype=torch.long)
        label_weights = anchors.new_zeros(num_valid_anchors, dtype=torch.float) # 标签权重初始化为0
        assign_metrics = anchors.new_zeros(  # 分配指标初始化为0，指示分配质量好不好，因为RTMDet采用的分类损失函数为'QualityFocalLoss'，这是用来计算分类损失的
            num_valid_anchors, dtype=torch.float)

        pos_inds = sampling_result.pos_inds # 从抽样结果中获取正样本索引
        neg_inds = sampling_result.neg_inds # 从抽样结果中获取负样本索引
        if len(pos_inds) &gt; 0:
            # point-based
            pos_bbox_targets = sampling_result.pos_gt_bboxes
            bbox_targets[pos_inds, :] = pos_bbox_targets # 更新负责预测正样本的bbox

            labels[pos_inds] = sampling_result.pos_gt_labels # 更新负责预测的正样本的类别标签
            if self.train_cfg['pos_weight'] &lt;= 0:
                label_weights[pos_inds] = 1.0
            else:
                label_weights[pos_inds] = self.train_cfg['pos_weight']
        if len(neg_inds) &gt; 0:
            label_weights[neg_inds] = 1.0

        # 采用iou评估分配质量
        class_assigned_gt_inds = torch.unique(
            sampling_result.pos_assigned_gt_inds)
        for gt_inds in class_assigned_gt_inds:
            gt_class_inds = pos_inds[sampling_result.pos_assigned_gt_inds ==
                                     gt_inds]
            assign_metrics[gt_class_inds] = assign_result.max_overlaps[
                gt_class_inds]
</code></pre>
<p>前面把数据增广过程中Pad加上的padding去掉了，只处理在真实图片范围内的anchors，现在把维度还原回去</p>
<pre><code class="language-python">        if unmap_outputs:
            num_total_anchors = flat_anchors.size(0)
            anchors = unmap(anchors, num_total_anchors, inside_flags)
            labels = unmap(
                labels, num_total_anchors, inside_flags, fill=self.num_classes)
            label_weights = unmap(label_weights, num_total_anchors,
                                  inside_flags)
            bbox_targets = unmap(bbox_targets, num_total_anchors, inside_flags)
            assign_metrics = unmap(assign_metrics, num_total_anchors,
                                   inside_flags)
</code></pre>
<p>返回结果</p>
<pre><code class="language-python">return (anchors, labels, label_weights, bbox_targets, assign_metrics,
                sampling_result)
</code></pre>
<p>接受返回的结果</p>
<pre><code class="language-python">        (all_anchors, all_labels, all_label_weights, all_bbox_targets,
         all_assign_metrics, sampling_results_list) = multi_apply(
             self._get_targets_single,
             cls_scores.detach(),
             bbox_preds.detach(),
             anchor_list,
             valid_flag_list,
             batch_gt_instances,
             batch_img_metas,
             batch_gt_instances_ignore,
             unmap_outputs=unmap_outputs)
        # no valid anchors
        if any([labels is None for labels in all_labels]):
            return None
</code></pre>
<p>上面把每张图片所有尺度的预测串联合在一起做正负样本的分配、采样等工作，现在再把结果拆分回不同的尺度</p>
<p>前面记录每个尺度的特征图有多少anchors</p>
<pre><code class="language-python">num_level_anchors = [anchors.size(0) for anchors in anchor_list[0]] 
</code></pre>
<p>拆分结果并返回</p>
<pre><code class="language-python">        anchors_list = images_to_levels(all_anchors, num_level_anchors)
        labels_list = images_to_levels(all_labels, num_level_anchors)
        label_weights_list = images_to_levels(all_label_weights,
                                              num_level_anchors)
        bbox_targets_list = images_to_levels(all_bbox_targets,
                                             num_level_anchors)
        assign_metrics_list = images_to_levels(all_assign_metrics,
                                               num_level_anchors)

        return (anchors_list, labels_list, label_weights_list,
                bbox_targets_list, assign_metrics_list, sampling_results_list)
</code></pre>
<p>至此，完成了targets的构建，维度与模型的预测输出一致，</p>
<h2 id="10-计算loss">10、计算loss</h2>
<p>上一步构建的targets如下：</p>
<pre><code class="language-python">        (anchor_list, labels_list, label_weights_list, bbox_targets_list,
         assign_metrics_list, sampling_results_list) = cls_reg_targets
</code></pre>
<p>接着按尺度计算loss</p>
<pre><code class="language-python">        losses_cls, losses_bbox,\
            cls_avg_factors, bbox_avg_factors = multi_apply(
                self.loss_by_feat_single, # 按尺度计算loss
                cls_scores,  # 分类分支的输出
                decoded_bboxes, # 回归分支的输出
                # 以下是构建的targets
                labels_list,
                label_weights_list,
                bbox_targets_list,
                assign_metrics_list,
                self.prior_generator.strides)
</code></pre>
<pre><code class="language-python">    def loss_by_feat_single(self, cls_score: Tensor, bbox_pred: Tensor,
                            labels: Tensor, label_weights: Tensor,
                            bbox_targets: Tensor, assign_metrics: Tensor,
                            stride: List[int]):
        &quot;&quot;&quot;Compute loss of a single scale level.

        Args:
            cls_score (Tensor): Box scores for each scale level
                Has shape (N, num_anchors * num_classes, H, W).
            bbox_pred (Tensor): Decoded bboxes for each scale
                level with shape (N, num_anchors * 4, H, W).
            labels (Tensor): Labels of each anchors with shape
                (N, num_total_anchors).
            label_weights (Tensor): Label weights of each anchor with shape
                (N, num_total_anchors).
            bbox_targets (Tensor): BBox regression targets of each anchor with
                shape (N, num_total_anchors, 4).
            assign_metrics (Tensor): Assign metrics with shape
                (N, num_total_anchors).
            stride (List[int]): Downsample stride of the feature map.

        Returns:
            dict[str, Tensor]: A dictionary of loss components.
        &quot;&quot;&quot;
        assert stride[0] == stride[1], 'h stride is not equal to w stride!'
        # 一维展开
        cls_score = cls_score.permute(0, 2, 3, 1).reshape(
            -1, self.cls_out_channels).contiguous()
        bbox_pred = bbox_pred.reshape(-1, 4)
        bbox_targets = bbox_targets.reshape(-1, 4)
        labels = labels.reshape(-1)
        assign_metrics = assign_metrics.reshape(-1)
        label_weights = label_weights.reshape(-1)
        targets = (labels, assign_metrics)

        # 计算分类损失
        loss_cls = self.loss_cls(
            cls_score, targets, label_weights, avg_factor=1.0)

        # 计算回归损失
        # FG cat_id: [0, num_classes -1], BG cat_id: num_classes 这是前景类别id的范围和北京类别的id，比如在coco数据集中共有80个类别，那么前景的类别为[0,79],背景的类别为80
        bg_class_ind = self.num_classes
        pos_inds = ((labels &gt;= 0)
                    &amp; (labels &lt; bg_class_ind)).nonzero().squeeze(1) # 获取正样本的索引

        if len(pos_inds) &gt; 0:
            pos_bbox_targets = bbox_targets[pos_inds]
            pos_bbox_pred = bbox_pred[pos_inds]

            pos_decode_bbox_pred = pos_bbox_pred
            pos_decode_bbox_targets = pos_bbox_targets

            # regression loss
            pos_bbox_weight = assign_metrics[pos_inds]

            loss_bbox = self.loss_bbox(
                pos_decode_bbox_pred,
                pos_decode_bbox_targets,
                weight=pos_bbox_weight,
                avg_factor=1.0)
        else:
            loss_bbox = bbox_pred.sum() * 0
            pos_bbox_weight = bbox_targets.new_tensor(0.)

        return loss_cls, loss_bbox, assign_metrics.sum(), pos_bbox_weight.sum()
</code></pre>
<h3 id="计算分类损失qualityfocalloss">计算分类损失QualityFocalLoss</h3>
<pre><code class="language-python">loss_cls=dict(type=&quot;QualityFocalLoss&quot;, use_sigmoid=True, beta=2.0, loss_weight=1.0),
</code></pre>
<pre><code class="language-python">@MODELS.register_module()
class QualityFocalLoss(nn.Module):
    r&quot;&quot;&quot;Quality Focal Loss (QFL) is a variant of `Generalized Focal Loss:
    Learning Qualified and Distributed Bounding Boxes for Dense Object
    Detection &lt;https://arxiv.org/abs/2006.04388&gt;`_.

    Args:
        use_sigmoid (bool): Whether sigmoid operation is conducted in QFL.
            Defaults to True.
        beta (float): The beta parameter for calculating the modulating factor.
            Defaults to 2.0.
        reduction (str): Options are &quot;none&quot;, &quot;mean&quot; and &quot;sum&quot;.
        loss_weight (float): Loss weight of current loss.
        activated (bool, optional): Whether the input is activated.
            If True, it means the input has been activated and can be
            treated as probabilities. Else, it should be treated as logits.
            Defaults to False.
    &quot;&quot;&quot;

    def __init__(self,
                 use_sigmoid=True,
                 beta=2.0,
                 reduction='mean',
                 loss_weight=1.0,
                 activated=False):
        super(QualityFocalLoss, self).__init__()
        assert use_sigmoid is True, 'Only sigmoid in QFL supported now.'
        self.use_sigmoid = use_sigmoid
        self.beta = beta
        self.reduction = reduction
        self.loss_weight = loss_weight
        self.activated = activated

    def forward(self,
                pred,
                target,
                weight=None,
                avg_factor=None,
                reduction_override=None):
        &quot;&quot;&quot;Forward function.

        Args:
            pred (torch.Tensor): Predicted joint representation of
                classification and quality (IoU) estimation with shape (N, C),
                C is the number of classes.
            target (Union(tuple([torch.Tensor]),Torch.Tensor)): The type is
                tuple, it should be included Target category label with
                shape (N,) and target quality label with shape (N,).The type
                is torch.Tensor, the target should be one-hot form with
                soft weights.
            weight (torch.Tensor, optional): The weight of loss for each
                prediction. Defaults to None.
            avg_factor (int, optional): Average factor that is used to average
                the loss. Defaults to None.
            reduction_override (str, optional): The reduction method used to
                override the original reduction method of the loss.
                Defaults to None.
        &quot;&quot;&quot;
        assert reduction_override in (None, 'none', 'mean', 'sum')
        reduction = (
            reduction_override if reduction_override else self.reduction)
        if self.use_sigmoid:
            if self.activated:
                calculate_loss_func = quality_focal_loss_with_prob
            else:
                calculate_loss_func = quality_focal_loss
            if isinstance(target, torch.Tensor):
                # the target shape with (N,C) or (N,C,...), which means
                # the target is one-hot form with soft weights.
                calculate_loss_func = partial(
                    quality_focal_loss_tensor_target, activated=self.activated)

            loss_cls = self.loss_weight * calculate_loss_func(
                pred,
                target,
                weight,
                beta=self.beta,
                reduction=reduction,
                avg_factor=avg_factor)
        else:
            raise NotImplementedError
        return loss_cls
</code></pre>
<pre><code class="language-python">@weighted_loss
def quality_focal_loss(pred, target, beta=2.0):
    r&quot;&quot;&quot;Quality Focal Loss (QFL) is from `Generalized Focal Loss: Learning
    Qualified and Distributed Bounding Boxes for Dense Object Detection
    &lt;https://arxiv.org/abs/2006.04388&gt;`_.

    Args:
        pred (torch.Tensor): Predicted joint representation of classification
            and quality (IoU) estimation with shape (N, C), C is the number of
            classes.
        target (tuple([torch.Tensor])): Target category label with shape (N,)
            and target quality label with shape (N,).
        beta (float): The beta parameter for calculating the modulating factor.
            Defaults to 2.0.

    Returns:
        torch.Tensor: Loss tensor with shape (N,).
    &quot;&quot;&quot;
    assert len(target) == 2, &quot;&quot;&quot;target for QFL must be a tuple of two elements,
        including category label and quality label, respectively&quot;&quot;&quot;
    # label denotes the category id, score denotes the quality score
    label, score = target

    # negatives are supervised by 0 quality score
    pred_sigmoid = pred.sigmoid()
    scale_factor = pred_sigmoid
    zerolabel = scale_factor.new_zeros(pred.shape)
    loss = F.binary_cross_entropy_with_logits(
        pred, zerolabel, reduction='none') * scale_factor.pow(beta)

    # FG cat_id: [0, num_classes -1], BG cat_id: num_classes
    bg_class_ind = pred.size(1)
    pos = ((label &gt;= 0) &amp; (label &lt; bg_class_ind)).nonzero().squeeze(1)
    pos_label = label[pos].long()
    # positives are supervised by bbox quality (IoU) score
    scale_factor = score[pos] - pred_sigmoid[pos, pos_label]
    loss[pos, pos_label] = F.binary_cross_entropy_with_logits(
        pred[pos, pos_label], score[pos],
        reduction='none') * scale_factor.abs().pow(beta)

    loss = loss.sum(dim=1, keepdim=False)
    return loss

</code></pre>
<h3 id="计算回归损失giouloss">计算回归损失GIoULoss</h3>
<pre><code class="language-python">loss_bbox=dict(type=&quot;GIoULoss&quot;, loss_weight=2.0),
</code></pre>
<pre><code class="language-python">@MODELS.register_module()
class GIoULoss(nn.Module):
    r&quot;&quot;&quot;`Generalized Intersection over Union: A Metric and A Loss for Bounding
    Box Regression &lt;https://arxiv.org/abs/1902.09630&gt;`_.

    Args:
        eps (float): Epsilon to avoid log(0).
        reduction (str): Options are &quot;none&quot;, &quot;mean&quot; and &quot;sum&quot;.
        loss_weight (float): Weight of loss.
    &quot;&quot;&quot;

    def __init__(self,
                 eps: float = 1e-6,
                 reduction: str = 'mean',
                 loss_weight: float = 1.0) -&gt; None:
        super().__init__()
        self.eps = eps
        self.reduction = reduction
        self.loss_weight = loss_weight

    def forward(self,
                pred: Tensor,
                target: Tensor,
                weight: Optional[Tensor] = None,
                avg_factor: Optional[int] = None,
                reduction_override: Optional[str] = None,
                **kwargs) -&gt; Tensor:
        &quot;&quot;&quot;Forward function.

        Args:
            pred (Tensor): Predicted bboxes of format (x1, y1, x2, y2),
                shape (n, 4).
            target (Tensor): The learning target of the prediction,
                shape (n, 4).
            weight (Optional[Tensor], optional): The weight of loss for each
                prediction. Defaults to None.
            avg_factor (Optional[int], optional): Average factor that is used
                to average the loss. Defaults to None.
            reduction_override (Optional[str], optional): The reduction method
                used to override the original reduction method of the loss.
                Defaults to None. Options are &quot;none&quot;, &quot;mean&quot; and &quot;sum&quot;.

        Returns:
            Tensor: Loss tensor.
        &quot;&quot;&quot;
        if weight is not None and not torch.any(weight &gt; 0):
            if pred.dim() == weight.dim() + 1:
                weight = weight.unsqueeze(1)
            return (pred * weight).sum()  # 0
        assert reduction_override in (None, 'none', 'mean', 'sum')
        reduction = (
            reduction_override if reduction_override else self.reduction)
        if weight is not None and weight.dim() &gt; 1:
            # TODO: remove this in the future
            # reduce the weight of shape (n, 4) to (n,) to match the
            # giou_loss of shape (n,)
            assert weight.shape == pred.shape
            weight = weight.mean(-1)
        loss = self.loss_weight * giou_loss(
            pred,
            target,
            weight,
            eps=self.eps,
            reduction=reduction,
            avg_factor=avg_factor,
            **kwargs)
        return loss
</code></pre>
<pre><code class="language-python">@weighted_loss
def giou_loss(pred: Tensor, target: Tensor, eps: float = 1e-7) -&gt; Tensor:
    r&quot;&quot;&quot;`Generalized Intersection over Union: A Metric and A Loss for Bounding
    Box Regression &lt;https://arxiv.org/abs/1902.09630&gt;`_.

    Args:
        pred (Tensor): Predicted bboxes of format (x1, y1, x2, y2),
            shape (n, 4).
        target (Tensor): Corresponding gt bboxes, shape (n, 4).
        eps (float): Epsilon to avoid log(0).

    Return:
        Tensor: Loss tensor.
    &quot;&quot;&quot;
    gious = bbox_overlaps(pred, target, mode='giou', is_aligned=True, eps=eps)
    loss = 1 - gious
    return loss
</code></pre>
<pre><code class="language-python">def bbox_overlaps(bboxes1, bboxes2, mode='iou', is_aligned=False, eps=1e-6):
    &quot;&quot;&quot;Calculate overlap between two set of bboxes.

    FP16 Contributed by https://github.com/open-mmlab/mmdetection/pull/4889
    Note:
        Assume bboxes1 is M x 4, bboxes2 is N x 4, when mode is 'iou',
        there are some new generated variable when calculating IOU
        using bbox_overlaps function:

        1) is_aligned is False
            area1: M x 1
            area2: N x 1
            lt: M x N x 2
            rb: M x N x 2
            wh: M x N x 2
            overlap: M x N x 1
            union: M x N x 1
            ious: M x N x 1

            Total memory:
                S = (9 x N x M + N + M) * 4 Byte,

            When using FP16, we can reduce:
                R = (9 x N x M + N + M) * 4 / 2 Byte
                R large than (N + M) * 4 * 2 is always true when N and M &gt;= 1.
                Obviously, N + M &lt;= N * M &lt; 3 * N * M, when N &gt;=2 and M &gt;=2,
                           N + 1 &lt; 3 * N, when N or M is 1.

            Given M = 40 (ground truth), N = 400000 (three anchor boxes
            in per grid, FPN, R-CNNs),
                R = 275 MB (one times)

            A special case (dense detection), M = 512 (ground truth),
                R = 3516 MB = 3.43 GB

            When the batch size is B, reduce:
                B x R

            Therefore, CUDA memory runs out frequently.

            Experiments on GeForce RTX 2080Ti (11019 MiB):

            |   dtype   |   M   |   N   |   Use    |   Real   |   Ideal   |
            |:----:|:----:|:----:|:----:|:----:|:----:|
            |   FP32   |   512 | 400000 | 8020 MiB |   --   |   --   |
            |   FP16   |   512 | 400000 |   4504 MiB | 3516 MiB | 3516 MiB |
            |   FP32   |   40 | 400000 |   1540 MiB |   --   |   --   |
            |   FP16   |   40 | 400000 |   1264 MiB |   276MiB   | 275 MiB |

        2) is_aligned is True
            area1: N x 1
            area2: N x 1
            lt: N x 2
            rb: N x 2
            wh: N x 2
            overlap: N x 1
            union: N x 1
            ious: N x 1

            Total memory:
                S = 11 x N * 4 Byte

            When using FP16, we can reduce:
                R = 11 x N * 4 / 2 Byte

        So do the 'giou' (large than 'iou').

        Time-wise, FP16 is generally faster than FP32.

        When gpu_assign_thr is not -1, it takes more time on cpu
        but not reduce memory.
        There, we can reduce half the memory and keep the speed.

    If ``is_aligned`` is ``False``, then calculate the overlaps between each
    bbox of bboxes1 and bboxes2, otherwise the overlaps between each aligned
    pair of bboxes1 and bboxes2.

    Args:
        bboxes1 (Tensor): shape (B, m, 4) in &lt;x1, y1, x2, y2&gt; format or empty.
        bboxes2 (Tensor): shape (B, n, 4) in &lt;x1, y1, x2, y2&gt; format or empty.
            B indicates the batch dim, in shape (B1, B2, ..., Bn).
            If ``is_aligned`` is ``True``, then m and n must be equal.
        mode (str): &quot;iou&quot; (intersection over union), &quot;iof&quot; (intersection over
            foreground) or &quot;giou&quot; (generalized intersection over union).
            Default &quot;iou&quot;.
        is_aligned (bool, optional): If True, then m and n must be equal.
            Default False.
        eps (float, optional): A value added to the denominator for numerical
            stability. Default 1e-6.

    Returns:
        Tensor: shape (m, n) if ``is_aligned`` is False else shape (m,)

    Example:
        &gt;&gt;&gt; bboxes1 = torch.FloatTensor([
        &gt;&gt;&gt;     [0, 0, 10, 10],
        &gt;&gt;&gt;     [10, 10, 20, 20],
        &gt;&gt;&gt;     [32, 32, 38, 42],
        &gt;&gt;&gt; ])
        &gt;&gt;&gt; bboxes2 = torch.FloatTensor([
        &gt;&gt;&gt;     [0, 0, 10, 20],
        &gt;&gt;&gt;     [0, 10, 10, 19],
        &gt;&gt;&gt;     [10, 10, 20, 20],
        &gt;&gt;&gt; ])
        &gt;&gt;&gt; overlaps = bbox_overlaps(bboxes1, bboxes2)
        &gt;&gt;&gt; assert overlaps.shape == (3, 3)
        &gt;&gt;&gt; overlaps = bbox_overlaps(bboxes1, bboxes2, is_aligned=True)
        &gt;&gt;&gt; assert overlaps.shape == (3, )

    Example:
        &gt;&gt;&gt; empty = torch.empty(0, 4)
        &gt;&gt;&gt; nonempty = torch.FloatTensor([[0, 0, 10, 9]])
        &gt;&gt;&gt; assert tuple(bbox_overlaps(empty, nonempty).shape) == (0, 1)
        &gt;&gt;&gt; assert tuple(bbox_overlaps(nonempty, empty).shape) == (1, 0)
        &gt;&gt;&gt; assert tuple(bbox_overlaps(empty, empty).shape) == (0, 0)
    &quot;&quot;&quot;

    assert mode in ['iou', 'iof', 'giou'], f'Unsupported mode {mode}'
    # Either the boxes are empty or the length of boxes' last dimension is 4
    assert (bboxes1.size(-1) == 4 or bboxes1.size(0) == 0)
    assert (bboxes2.size(-1) == 4 or bboxes2.size(0) == 0)

    # Batch dim must be the same
    # Batch dim: (B1, B2, ... Bn)
    assert bboxes1.shape[:-2] == bboxes2.shape[:-2]
    batch_shape = bboxes1.shape[:-2]

    rows = bboxes1.size(-2)
    cols = bboxes2.size(-2)
    if is_aligned:
        assert rows == cols

    if rows * cols == 0:
        if is_aligned:
            return bboxes1.new(batch_shape + (rows, ))
        else:
            return bboxes1.new(batch_shape + (rows, cols))

    area1 = (bboxes1[..., 2] - bboxes1[..., 0]) * (
        bboxes1[..., 3] - bboxes1[..., 1])
    area2 = (bboxes2[..., 2] - bboxes2[..., 0]) * (
        bboxes2[..., 3] - bboxes2[..., 1])

    if is_aligned:
        lt = torch.max(bboxes1[..., :2], bboxes2[..., :2])  # [B, rows, 2]
        rb = torch.min(bboxes1[..., 2:], bboxes2[..., 2:])  # [B, rows, 2]

        wh = fp16_clamp(rb - lt, min=0)
        overlap = wh[..., 0] * wh[..., 1]

        if mode in ['iou', 'giou']:
            union = area1 + area2 - overlap
        else:
            union = area1
        if mode == 'giou':
            enclosed_lt = torch.min(bboxes1[..., :2], bboxes2[..., :2])
            enclosed_rb = torch.max(bboxes1[..., 2:], bboxes2[..., 2:])
    else:
        lt = torch.max(bboxes1[..., :, None, :2],
                       bboxes2[..., None, :, :2])  # [B, rows, cols, 2]
        rb = torch.min(bboxes1[..., :, None, 2:],
                       bboxes2[..., None, :, 2:])  # [B, rows, cols, 2]

        wh = fp16_clamp(rb - lt, min=0)
        overlap = wh[..., 0] * wh[..., 1]

        if mode in ['iou', 'giou']:
            union = area1[..., None] + area2[..., None, :] - overlap
        else:
            union = area1[..., None]
        if mode == 'giou':
            enclosed_lt = torch.min(bboxes1[..., :, None, :2],
                                    bboxes2[..., None, :, :2])
            enclosed_rb = torch.max(bboxes1[..., :, None, 2:],
                                    bboxes2[..., None, :, 2:])

    eps = union.new_tensor([eps])
    union = torch.max(union, eps)
    ious = overlap / union
    if mode in ['iou', 'iof']:
        return ious
    # calculate gious
    enclose_wh = fp16_clamp(enclosed_rb - enclosed_lt, min=0)
    enclose_area = enclose_wh[..., 0] * enclose_wh[..., 1]
    enclose_area = torch.max(enclose_area, eps)
    gious = ious - (enclose_area - union) / enclose_area
    return gious

</code></pre>
<p>对不同尺度的分类损失和回归损失取均值</p>
<pre><code class="language-pyhton">        cls_avg_factor = reduce_mean(sum(cls_avg_factors)).clamp_(min=1).item() # 不同尺度的assign_metrics.sum()的均值
        losses_cls = list(map(lambda x: x / cls_avg_factor, losses_cls)) # 每个尺度的losses_cls都除以cls_avg_factor

        bbox_avg_factor = reduce_mean( # 同上
            sum(bbox_avg_factors)).clamp_(min=1).item()
        losses_bbox = list(map(lambda x: x / bbox_avg_factor, losses_bbox))
        return dict(loss_cls=losses_cls, loss_bbox=losses_bbox)
</code></pre>
<p>loss字典最终在BaseModel的def train_step()函数中被处理并传给优化器封装器进行模型参数的更新</p>
<pre><code class="language-python">    def train_step(self, data: Union[dict, tuple, list],
                   optim_wrapper: OptimWrapper) -&gt; Dict[str, torch.Tensor]:
        # Enable automatic mixed precision training context.
        with optim_wrapper.optim_context(self):
            data = self.data_preprocessor(data, True)
            losses = self._run_forward(data, mode='loss')  # type: ignore
        parsed_losses, log_vars = self.parse_losses(losses)  # type: ignore # 大概是对分类损失和回归损失进行加权求和
        optim_wrapper.update_params(parsed_losses)
        return log_vars
</code></pre>
]]></content>
    </entry>
</feed>